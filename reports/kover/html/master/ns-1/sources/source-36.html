


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > WebBrowser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">kweb</a>
</div>

<h1>Coverage Summary for Class: WebBrowser (kweb)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">WebBrowser</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (14/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (26/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.2%
  </span>
  <span class="absValue">
    (86/110)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.2%
  </span>
  <span class="absValue">
    (618/833)
  </span>
</td>
</tr>
  <tr>
    <td class="name">WebBrowser$callJsFunctionWithResult$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$CatcherType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$FuncDeclaration</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$gurl$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$OutboundMessageCatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$plugins$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$url$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$url$2$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$UrlSource</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$urlSource$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (44/44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$urlSource$2$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$urlSource$2$1$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$urlSource$2$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (28/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WebBrowser$UrlSource$Source</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    78.9%
  </span>
  <span class="absValue">
    (30/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.3%
  </span>
  <span class="absValue">
    (32/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81%
  </span>
  <span class="absValue">
    (115/142)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (836/1074)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package kweb
&nbsp;
&nbsp;import io.mola.galimatias.URL
&nbsp;import kotlinx.coroutines.CompletableDeferred
&nbsp;import kotlinx.serialization.json.JsonElement
&nbsp;import kotlinx.serialization.json.JsonPrimitive
&nbsp;import kweb.client.FunctionCall
&nbsp;import kweb.client.HttpRequestInfo
&nbsp;import kweb.client.Server2ClientMessage
&nbsp;import kweb.html.Document
&nbsp;import kweb.html.HtmlDocumentSupplier
&nbsp;import kweb.html.Window
&nbsp;import kweb.html.events.Event
&nbsp;import kweb.plugins.KwebPlugin
&nbsp;import kweb.state.KVar
&nbsp;import kweb.state.ReversibleFunction
&nbsp;import kweb.util.pathQueryFragment
&nbsp;import kweb.util.random
&nbsp;import mu.KotlinLogging
&nbsp;import java.util.*
&nbsp;import java.util.concurrent.ConcurrentHashMap
&nbsp;import java.util.concurrent.atomic.AtomicInteger
&nbsp;import java.util.concurrent.atomic.AtomicReference
&nbsp;import kotlin.contracts.ExperimentalContracts
&nbsp;import kotlin.math.abs
&nbsp;import kotlin.reflect.KClass
&nbsp;import kotlin.reflect.jvm.jvmName
&nbsp;
&nbsp;private val logger = KotlinLogging.logger {}
&nbsp;
&nbsp;/**
&nbsp; * A conduit for communicating with a remote web browser, can be used to execute JavaScript and evaluate JavaScript
&nbsp; * expressions and retrieve the result.
&nbsp; */
&nbsp;
<b class="fc">&nbsp;class WebBrowser(val sessionId: String, val httpRequestInfo: HttpRequestInfo, val kweb: Kweb) {</b>
&nbsp;
<b class="fc">&nbsp;    private val idCounter = AtomicInteger(0)</b>
&nbsp;
<b class="fc">&nbsp;    private val closeListeners : ConcurrentHashMap&lt;Int, () -&gt; Unit&gt; = ConcurrentHashMap()</b>
&nbsp;
&nbsp;    /**
&nbsp;     * During page render, the initial HTML document will be available for modification as a
&nbsp;     * [JSoup Document](https://jsoup.org/) in this [AtomicReference].
&nbsp;     *
&nbsp;     * Callers to [callJsFunction] may check for this being non-null, and if so edit the document
&nbsp;     * *instead* of some or all of the JavaScript they must call.
&nbsp;     *
&nbsp;     * The purpose of this is to implement Server-Side Rendering.
&nbsp;     */
<b class="fc">&nbsp;    val htmlDocument = AtomicReference&lt;org.jsoup.nodes.Document?&gt;(null)</b>
&nbsp;
<b class="fc">&nbsp;    fun generateId(): String = idCounter.getAndIncrement().toString(36)</b>
&nbsp;
<b class="fc">&nbsp;    private val cachedFunctions = ConcurrentHashMap&lt;String, Int&gt;()</b>
&nbsp;
<b class="fc">&nbsp;    private val plugins: Map&lt;KClass&lt;out KwebPlugin&gt;, KwebPlugin&gt; by lazy {</b>
<b class="nc">&nbsp;        HtmlDocumentSupplier.appliedPlugins.map { it::class to it }.toMap()</b>
&nbsp;    }
&nbsp;
&nbsp;    //TODO I think some of these things could be renamed for clarity. I think it is understandable as is, but there is room for improvement
&nbsp;    enum class CatcherType {
<b class="fc">&nbsp;        EVENT, IMMEDIATE_EVENT, RENDER</b>
&nbsp;    }
<b class="fc">&nbsp;    data class OutboundMessageCatcher(var catcherType: CatcherType, val functionList: MutableList&lt;FunctionCall&gt;)</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Allow us to catch outbound messages temporarily and only for this thread.  This is used for immediate
&nbsp;     * execution of event handlers, see `Element.onImmediate`
&nbsp;     */
<b class="fc">&nbsp;    val outboundMessageCatcher: ThreadLocal&lt;OutboundMessageCatcher?&gt; = ThreadLocal.withInitial { null }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Are outbound messages being cached for this thread (for example, because we&#39;re inside an immediateEvent callback block)?
&nbsp;     */
<b class="fc">&nbsp;    fun isCatchingOutbound() = outboundMessageCatcher.get()?.catcherType</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Execute a block of code in which any JavaScript sent to the browser during the execution of the block will be stored
&nbsp;     * and returned by this function.
&nbsp;     *
&nbsp;     * The main use-case is recording changes made to the DOM within an onImmediate event callback so that these can be
&nbsp;     * replayed in the browser when an event is triggered without a server round-trip.
&nbsp;     */
&nbsp;    fun &lt;R&gt; catchOutbound(catchingType: CatcherType, f: () -&gt; R): Pair&lt;List&lt;FunctionCall&gt;, R&gt; {
<b class="pc">&nbsp;        require(outboundMessageCatcher.get() == null) { &quot;Can&#39;t nest withThreadLocalOutboundMessageCatcher()&quot; }</b>
&nbsp;
<b class="fc">&nbsp;        val jsList = ArrayList&lt;FunctionCall&gt;()</b>
<b class="fc">&nbsp;        outboundMessageCatcher.set(OutboundMessageCatcher(catchingType, jsList))</b>
<b class="fc">&nbsp;        val r = f()</b>
<b class="fc">&nbsp;        outboundMessageCatcher.set(null)</b>
<b class="fc">&nbsp;        return Pair(jsList, r)</b>
&nbsp;    }
&nbsp;
&nbsp;    // TODO: Maybe use contract callsInPlace on f
&nbsp;    fun &lt;R&gt; batch(catchingType: CatcherType, f: () -&gt; R) : R {
<b class="fc">&nbsp;        val catchOutboundRet = catchOutbound(catchingType, f)</b>
<b class="fc">&nbsp;        val server2ClientMessage = Server2ClientMessage(sessionId, catchOutboundRet.first)</b>
<b class="fc">&nbsp;        kweb.sendMessage(sessionId, server2ClientMessage)</b>
<b class="fc">&nbsp;        return catchOutboundRet.second</b>
&nbsp;    }
&nbsp;
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
&nbsp;    internal fun &lt;P : KwebPlugin&gt; plugin(plugin: KClass&lt;out P&gt;): P {
<b class="nc">&nbsp;        return (plugins[plugin] ?: error(&quot;Plugin $plugin is missing&quot;)) as P</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that a specific plugin be provided in [Kweb.plugins], throws an exception if not.
&nbsp;     */
&nbsp;    internal fun require(vararg requiredPlugins: KClass&lt;out KwebPlugin&gt;) {
<b class="nc">&nbsp;        val missing = HashSet&lt;String&gt;()</b>
<b class="nc">&nbsp;        for (requiredPlugin in requiredPlugins) {</b>
<b class="nc">&nbsp;            if (!plugins.contains(requiredPlugin)) missing.add(requiredPlugin.simpleName ?: requiredPlugin.jvmName)</b>
&nbsp;        }
<b class="nc">&nbsp;        if (missing.isNotEmpty()) {</b>
<b class="nc">&nbsp;            error(&quot;Plugin(s) ${missing.joinToString(separator = &quot;, &quot;)} required but not passed to Kweb constructor&quot;)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    data class FuncDeclaration(val js: String, val params: String)</b>
&nbsp;    /**
&nbsp;     * this function substitutes &quot;{}&quot; in user supplied javascript, for randomly generated variable names
&nbsp;     */
&nbsp;    private fun makeJsFunction(rawJs: String): FuncDeclaration {
<b class="fc">&nbsp;        val stringBuilder = StringBuilder()</b>
<b class="fc">&nbsp;        var variableCount = 1</b>
<b class="fc">&nbsp;        val params = mutableListOf&lt;String&gt;()</b>
<b class="fc">&nbsp;        var i = 0</b>
<b class="fc">&nbsp;        while (i &lt; rawJs.length) {</b>
<b class="fc">&nbsp;            if (rawJs[i] == &#39;{&#39; &amp;&amp; rawJs[i+1] == &#39;}&#39;){</b>
<b class="fc">&nbsp;                val jsVarName = &quot;auto_var_$variableCount&quot;</b>
<b class="fc">&nbsp;                stringBuilder.append(jsVarName)</b>
<b class="fc">&nbsp;                params.add(jsVarName)</b>
<b class="fc">&nbsp;                variableCount++</b>
<b class="fc">&nbsp;                i++//Since we matched the right bracket, we have to do an extra increment here,</b>
&nbsp;            // to avoid checking the right bracket a second time.
&nbsp;            } else {
<b class="fc">&nbsp;                stringBuilder.append(rawJs[i])</b>
&nbsp;            }
<b class="fc">&nbsp;            i++</b>
&nbsp;        }
<b class="fc">&nbsp;        return FuncDeclaration(stringBuilder.toString(), params.joinToString(separator = &quot;,&quot;))</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun generateCacheId() : Int {
<b class="fc">&nbsp;        return abs(random.nextInt())</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calls a JavaScript function in the browser passing it the supplied parameters, which
&nbsp;     * will be substituted into [jsBody] wherever a `{}` is present.
&nbsp;     *
&nbsp;     * Notes:
&nbsp;     * * The `{}` will be replaced by a variable so `&quot;one {} three&quot;` won&#39;t work, use &#39;&quot;one &quot; + {} + &quot; three&quot;&#39;
&nbsp;     *   instead.
&nbsp;     * * If your JavaScript needs to use an empty JavaScript object, just insert a space
&nbsp;     *   between the {}s, eg. `{ }` so it won&#39;t be treated as a parameter
&nbsp;     */
&nbsp;    fun callJsFunction(jsBody: String, vararg args: JsonElement) {
<b class="fc">&nbsp;        val functionCall  = if (cachedFunctions[jsBody] != null) {</b>
<b class="fc">&nbsp;            FunctionCall(jsId = cachedFunctions[jsBody], arguments = listOf(*args))</b>
&nbsp;        } else {
<b class="fc">&nbsp;            val cacheId = generateCacheId()</b>
<b class="fc">&nbsp;            val func = makeJsFunction(jsBody)</b>
&nbsp;            //we add the user&#39;s unmodified js as a key and the cacheId as it&#39;s value in the hashmap
<b class="fc">&nbsp;            cachedFunctions[jsBody] = cacheId</b>
&nbsp;            //we send the modified js to the client to be cached there.
&nbsp;            //we don&#39;t cache the modified js on the server, because then we&#39;d have to modify JS on the server, everytime we want to check the server&#39;s cache
<b class="fc">&nbsp;            FunctionCall(jsId = cacheId, js = func.js, parameters = func.params,</b>
<b class="fc">&nbsp;                    arguments = listOf(*args))</b>
&nbsp;        }
<b class="pc">&nbsp;        val debugInfo: DebugInfo? = if(!kweb.debug) null else {</b>
<b class="fc">&nbsp;            DebugInfo(jsBody, &quot;executing&quot;, Throwable())</b>
&nbsp;        }
<b class="fc">&nbsp;        val outboundMessageCatcher = outboundMessageCatcher.get()</b>
<b class="fc">&nbsp;        if (outboundMessageCatcher == null) {</b>
<b class="fc">&nbsp;            kweb.callJs(sessionId, functionCall, debugInfo)</b>
&nbsp;        } else {
<b class="fc">&nbsp;            logger.debug(&quot;Temporarily storing message for $sessionId in threadlocal outboundMessageCatcher&quot;)</b>
<b class="fc">&nbsp;            outboundMessageCatcher.functionList.add(functionCall)</b>
&nbsp;            //If we are collecting calls for an immediate event, we run the risk of the client calling JS code that has yet to be cached
&nbsp;            //A functionCall object having a non null js parameter, means the function has not been cached.
&nbsp;            //So we directly execute a line of JS code that will cache the function object, using JS generated by createCacheFunctionJs
<b class="fc">&nbsp;            if (outboundMessageCatcher.catcherType == CatcherType.IMMEDIATE_EVENT) {</b>
<b class="pc">&nbsp;                if (functionCall.js != null) {</b>
<b class="fc">&nbsp;                    val cacheJs = createCacheFunctionJs(functionCall.jsId!!, functionCall.js, functionCall.parameters)</b>
<b class="fc">&nbsp;                    kweb.callJs(sessionId, FunctionCall(jsId = null, js = cacheJs), null)</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun callJsFunction_sample() {
<b class="nc">&nbsp;        callJsFunction(&quot;alert({});&quot;, JsonPrimitive(&quot;Hello, I&#39;m an alert box!&quot;))</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calls a JavaScript function that can return a value via a [callback]
&nbsp;     *
&nbsp;     * @see callJsFunction
&nbsp;     */
&nbsp;    fun callJsFunctionWithCallback(jsBody: String, callbackId: Int, callback: (JsonElement) -&gt; Unit, vararg args: JsonElement) {
<b class="fc">&nbsp;        val functionCall = if (cachedFunctions[jsBody] != null) {</b>
<b class="fc">&nbsp;            FunctionCall(jsId = cachedFunctions[jsBody], arguments = listOf(*args), callbackId = callbackId)</b>
&nbsp;        } else {
<b class="fc">&nbsp;            val cacheId = generateCacheId()</b>
<b class="fc">&nbsp;            val func = makeJsFunction(jsBody)</b>
&nbsp;            //we add the user&#39;s unmodified js as a key and the cacheId as it&#39;s value in the hashmap
<b class="fc">&nbsp;            cachedFunctions[jsBody] = cacheId</b>
&nbsp;            //we send the modified js to the client to be cached there.
&nbsp;            //we don&#39;t cache the modified js on the server, because then we&#39;d have to modify JS on the server, everytime we want to check the server&#39;s cache
<b class="fc">&nbsp;            FunctionCall(jsId = cacheId, js = func.js, parameters = func.params,</b>
<b class="fc">&nbsp;                    arguments = listOf(*args), callbackId = callbackId)</b>
&nbsp;        }
<b class="pc">&nbsp;        val debugInfo: DebugInfo? = if(!kweb.debug) null else {</b>
<b class="fc">&nbsp;            DebugInfo(jsBody, &quot;executing&quot;, Throwable())</b>
&nbsp;        }
<b class="fc">&nbsp;        val outboundMessageCatcher = outboundMessageCatcher.get()</b>
<b class="fc">&nbsp;        if (outboundMessageCatcher == null) {</b>
<b class="fc">&nbsp;            kweb.callJs(sessionId, functionCall, debugInfo)</b>
&nbsp;        } else {
<b class="fc">&nbsp;            logger.debug(&quot;Temporarily storing message for $sessionId in threadlocal outboundMessageCatcher&quot;)</b>
<b class="fc">&nbsp;            outboundMessageCatcher.functionList.add(functionCall)</b>
<b class="pc">&nbsp;            if (outboundMessageCatcher.catcherType == CatcherType.IMMEDIATE_EVENT) {</b>
<b class="nc">&nbsp;                if (functionCall.js != null) {</b>
<b class="nc">&nbsp;                    val cacheJs = createCacheFunctionJs(functionCall.jsId!!, functionCall.js, functionCall.parameters)</b>
<b class="nc">&nbsp;                    kweb.callJs(sessionId, FunctionCall(jsId = null, js = cacheJs), null)</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        kweb.addCallback(sessionId, functionCall.callbackId!!, callback)</b>
&nbsp;    }
&nbsp;
&nbsp;    fun addCloseListener(listener: () -&gt; Unit) : Int {
<b class="fc">&nbsp;        val id = random.nextInt()</b>
<b class="fc">&nbsp;        this.closeListeners[id] = listener</b>
<b class="fc">&nbsp;        return id</b>
&nbsp;    }
&nbsp;
&nbsp;    fun removeCloseListener(id: Int) {
<b class="nc">&nbsp;        synchronized(this) {</b>
<b class="nc">&nbsp;            this.closeListeners.remove(id)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun close() {
<b class="fc">&nbsp;        synchronized(this) {</b>
<b class="fc">&nbsp;            try {</b>
<b class="fc">&nbsp;                this.closeListeners.values.forEach { it() }</b>
<b class="nc">&nbsp;            } catch (e : Exception) {</b>
<b class="nc">&nbsp;                logger.warn(&quot;Exception while calling closeListener&quot;, e)</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private fun createCacheFunctionJs(cacheId: Int, functionBody: String, params: String? = null) : String {</b>
<b class="pc">&nbsp;        params?.let {</b>
&nbsp;            //language=JavaScript
<b class="fc">&nbsp;            return &quot;&quot;&quot;cachedFunctions[$cacheId] = new Function(&quot;$params&quot;, &quot;$functionBody&quot;);&quot;&quot;&quot;</b>
&nbsp;        }
&nbsp;        //language=JavaScript
<b class="nc">&nbsp;        return &quot;&quot;&quot;cachedFunctions[$cacheId] = new Function(&quot;$functionBody&quot;);&quot;&quot;&quot;</b>
&nbsp;    }
&nbsp;
&nbsp;    fun removeCallback(callbackId: Int) {
<b class="fc">&nbsp;        kweb.removeCallback(sessionId, callbackId)</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calls a JavaScript function that can return a value, note that to do this [jsBody] **MUST** end with
&nbsp;     * a `return` statement, eg:
&nbsp;     *
&nbsp;     * ```kotlin
&nbsp;     *   val result = callJsFunctionWithResult(&quot;return 1 + 1&quot;)
&nbsp;     * ```
&nbsp;     */
&nbsp;    suspend fun callJsFunctionWithResult(jsBody: String, vararg args: JsonElement): JsonElement {
<b class="nc">&nbsp;        require(isCatchingOutbound() == null) {</b>
<b class="nc">&nbsp;            &quot;You can not read the DOM inside a batched code block&quot;</b>
&nbsp;        }
<b class="nc">&nbsp;        val callbackId = abs(random.nextInt())</b>
<b class="nc">&nbsp;        val cd = CompletableDeferred&lt;JsonElement&gt;()</b>
<b class="nc">&nbsp;        callJsFunctionWithCallback(jsBody, callbackId = callbackId, callback = { response -&gt;</b>
<b class="nc">&nbsp;            cd.complete(response)</b>
<b class="nc">&nbsp;        }, *args)</b>
<b class="nc">&nbsp;        return cd.await()</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    val doc = Document(this)</b>
&nbsp;
<b class="fc">&nbsp;    val window = Window(this)</b>
&nbsp;
<b class="fc">&nbsp;    private data class UrlSource(val url : String, val source : Source) {</b>
&nbsp;        enum class Source {
<b class="fc">&nbsp;            Initial, Client, Server</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * We must keep track of whether a URL change was initiated on the client or on the
&nbsp;     * server to avoid unnecessarily pushing a new URL state back to the client when
&nbsp;     * that&#39;s where it originated.
&nbsp;     *
&nbsp;     * Suspect this was the cause of https://github.com/kwebio/kweb-core/issues/219
&nbsp;     */
<b class="fc">&nbsp;    private val urlSource : KVar&lt;UrlSource&gt; by lazy {</b>
<b class="fc">&nbsp;        val originRelativeURL = URL.parse(httpRequestInfo.requestedUrl).pathQueryFragment</b>
<b class="fc">&nbsp;        val urlSource = KVar(UrlSource(originRelativeURL, UrlSource.Source.Initial))</b>
&nbsp;
<b class="fc">&nbsp;        urlSource.addListener { oldState, newState -&gt;</b>
<b class="fc">&nbsp;            logger.debug { &quot;urlSource $oldState -&gt; $newState&quot; }</b>
<b class="fc">&nbsp;            if (newState.source == UrlSource.Source.Server) {</b>
<b class="fc">&nbsp;                pushState(newState.url)</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        window.on(</b>
&nbsp;            //language=JavaScript
<b class="fc">&nbsp;            retrieveJs = &quot;window.location.href&quot;</b>
<b class="fc">&nbsp;        ).popstate { event : Event -&gt;</b>
<b class="pc">&nbsp;            if (event.retrieved is JsonPrimitive &amp;&amp; event.retrieved.isString) {</b>
<b class="fc">&nbsp;                urlSource.value = UrlSource(</b>
<b class="fc">&nbsp;                    URL.parse(event.retrieved.content).pathQueryFragment,</b>
<b class="fc">&nbsp;                    UrlSource.Source.Client</b>
&nbsp;                )
&nbsp;            } else {
<b class="nc">&nbsp;                error(&quot;event.retrieved isn&#39;t a string&quot;)</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        urlSource</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The URL of the page, relative to the origin - so for the page `http://foo/bar?baz#1`, the value would be
&nbsp;     * `/bar?baz#1`.
&nbsp;     *
&nbsp;     * When this KVar is modified the browser will automatically update the URL in the browser along with any DOM
&nbsp;     * elements based on this [url] (this will be handled automatically by [kweb.routing.route]).
&nbsp;     *
&nbsp;     * If the [popstate event](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) fires
&nbsp;     * in the browser, for example if the Back button is pressed, then this URL will also update - potentially
&nbsp;     * triggering re-renders of any DOM elements that depend on the URL.
&nbsp;     */
&nbsp;    val url: KVar&lt;String&gt;
<b class="fc">&nbsp;            by lazy {</b>
<b class="fc">&nbsp;                urlSource.map(object : ReversibleFunction&lt;UrlSource, String&gt;(&quot;urlSource&quot;) {</b>
<b class="fc">&nbsp;                    override fun invoke(from: UrlSource) = from.url</b>
&nbsp;                    override fun reverse(original: UrlSource, change: String) =
<b class="fc">&nbsp;                        if (change != original.url) {</b>
<b class="fc">&nbsp;                            UrlSource(change, UrlSource.Source.Server)</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            UrlSource(change, original.source)</b>
&nbsp;                        }
&nbsp;                })
&nbsp;            }
&nbsp;
&nbsp;    private fun pushState(url: String) {
<b class="pc">&nbsp;        if (!url.startsWith(&#39;/&#39;)) {</b>
<b class="nc">&nbsp;            logger.warn(&quot;pushState should only be called with origin-relative URLs (ie. they should start with a /)&quot;)</b>
&nbsp;        }
&nbsp;        //{ } is used to initialize an empty map here. Without the space, it would be treated
&nbsp;        //as a variable using Kweb&#39;s template syntax
&nbsp;        //language=JavaScript
<b class="fc">&nbsp;        callJsFunction(&quot;&quot;&quot;</b>
&nbsp;        history.pushState({ }, &quot;&quot;, {});
<b class="fc">&nbsp;        &quot;&quot;&quot;.trimIndent(), JsonPrimitive(url))</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The absolute URL of the page, mapped to a [io.mola.galimatias.URL](http://galimatias.mola.io/apidocs/0.2.0/io/mola/galimatias/URL.html) for convenience.
&nbsp;     */
<b class="fc">&nbsp;    val gurl : KVar&lt;URL&gt; = url.map(object : ReversibleFunction&lt;String, URL&gt;(label = &quot;gurl&quot;) {</b>
&nbsp;        override fun invoke(from: String): URL {
<b class="fc">&nbsp;            return URL.parse(this@WebBrowser.httpRequestInfo.requestedUrl).resolve(from)</b>
&nbsp;        }
&nbsp;
&nbsp;        override fun reverse(original: String, change: URL): String {
<b class="fc">&nbsp;            return change.pathQueryFragment</b>
&nbsp;        }
&nbsp;    } )
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-12-23 21:26</div>
</div>
</body>
</html>
