


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > WebBrowserKt</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">kweb</a>
</div>

<h1>Coverage Summary for Class: WebBrowserKt (kweb)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">WebBrowserKt</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
</tr>
  <tr>
    <td class="name">WebBrowserKt$logger$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package kweb
&nbsp;
&nbsp;import io.mola.galimatias.URL
&nbsp;import kotlinx.coroutines.CompletableDeferred
&nbsp;import kotlinx.serialization.json.JsonElement
&nbsp;import kotlinx.serialization.json.JsonPrimitive
&nbsp;import kweb.client.FunctionCall
&nbsp;import kweb.client.HttpRequestInfo
&nbsp;import kweb.client.Server2ClientMessage
&nbsp;import kweb.html.Document
&nbsp;import kweb.html.HtmlDocumentSupplier
&nbsp;import kweb.html.Window
&nbsp;import kweb.html.events.Event
&nbsp;import kweb.plugins.KwebPlugin
&nbsp;import kweb.state.KVar
&nbsp;import kweb.state.ReversibleFunction
&nbsp;import kweb.util.pathQueryFragment
&nbsp;import kweb.util.random
&nbsp;import mu.KotlinLogging
&nbsp;import java.util.*
&nbsp;import java.util.concurrent.ConcurrentHashMap
&nbsp;import java.util.concurrent.atomic.AtomicInteger
&nbsp;import java.util.concurrent.atomic.AtomicReference
&nbsp;import kotlin.contracts.ExperimentalContracts
&nbsp;import kotlin.math.abs
&nbsp;import kotlin.reflect.KClass
&nbsp;import kotlin.reflect.jvm.jvmName
&nbsp;
<b class="pc">&nbsp;private val logger = KotlinLogging.logger {}</b>
&nbsp;
&nbsp;/**
&nbsp; * A conduit for communicating with a remote web browser, can be used to execute JavaScript and evaluate JavaScript
&nbsp; * expressions and retrieve the result.
&nbsp; */
&nbsp;
&nbsp;class WebBrowser(val sessionId: String, val httpRequestInfo: HttpRequestInfo, val kweb: Kweb) {
&nbsp;
&nbsp;    private val idCounter = AtomicInteger(0)
&nbsp;
&nbsp;    private val closeListeners : ConcurrentHashMap&lt;Int, () -&gt; Unit&gt; = ConcurrentHashMap()
&nbsp;
&nbsp;    /**
&nbsp;     * During page render, the initial HTML document will be available for modification as a
&nbsp;     * [JSoup Document](https://jsoup.org/) in this [AtomicReference].
&nbsp;     *
&nbsp;     * Callers to [callJsFunction] may check for this being non-null, and if so edit the document
&nbsp;     * *instead* of some or all of the JavaScript they must call.
&nbsp;     *
&nbsp;     * The purpose of this is to implement Server-Side Rendering.
&nbsp;     */
&nbsp;    val htmlDocument = AtomicReference&lt;org.jsoup.nodes.Document?&gt;(null)
&nbsp;
&nbsp;    fun generateId(): String = idCounter.getAndIncrement().toString(36)
&nbsp;
&nbsp;    private val cachedFunctions = ConcurrentHashMap&lt;String, Int&gt;()
&nbsp;
&nbsp;    private val plugins: Map&lt;KClass&lt;out KwebPlugin&gt;, KwebPlugin&gt; by lazy {
&nbsp;        HtmlDocumentSupplier.appliedPlugins.map { it::class to it }.toMap()
&nbsp;    }
&nbsp;
&nbsp;    //TODO I think some of these things could be renamed for clarity. I think it is understandable as is, but there is room for improvement
&nbsp;    enum class CatcherType {
&nbsp;        EVENT, IMMEDIATE_EVENT, RENDER
&nbsp;    }
&nbsp;    data class OutboundMessageCatcher(var catcherType: CatcherType, val functionList: MutableList&lt;FunctionCall&gt;)
&nbsp;
&nbsp;    /**
&nbsp;     * Allow us to catch outbound messages temporarily and only for this thread.  This is used for immediate
&nbsp;     * execution of event handlers, see `Element.onImmediate`
&nbsp;     */
&nbsp;    val outboundMessageCatcher: ThreadLocal&lt;OutboundMessageCatcher?&gt; = ThreadLocal.withInitial { null }
&nbsp;
&nbsp;    /**
&nbsp;     * Are outbound messages being cached for this thread (for example, because we&#39;re inside an immediateEvent callback block)?
&nbsp;     */
&nbsp;    fun isCatchingOutbound() = outboundMessageCatcher.get()?.catcherType
&nbsp;
&nbsp;    /**
&nbsp;     * Execute a block of code in which any JavaScript sent to the browser during the execution of the block will be stored
&nbsp;     * and returned by this function.
&nbsp;     *
&nbsp;     * The main use-case is recording changes made to the DOM within an onImmediate event callback so that these can be
&nbsp;     * replayed in the browser when an event is triggered without a server round-trip.
&nbsp;     */
&nbsp;    fun &lt;R&gt; catchOutbound(catchingType: CatcherType, f: () -&gt; R): Pair&lt;List&lt;FunctionCall&gt;, R&gt; {
&nbsp;        require(outboundMessageCatcher.get() == null) { &quot;Can&#39;t nest withThreadLocalOutboundMessageCatcher()&quot; }
&nbsp;
&nbsp;        val jsList = ArrayList&lt;FunctionCall&gt;()
&nbsp;        outboundMessageCatcher.set(OutboundMessageCatcher(catchingType, jsList))
&nbsp;        val r = f()
&nbsp;        outboundMessageCatcher.set(null)
&nbsp;        return Pair(jsList, r)
&nbsp;    }
&nbsp;
&nbsp;    // TODO: Maybe use contract callsInPlace on f
&nbsp;    fun &lt;R&gt; batch(catchingType: CatcherType, f: () -&gt; R) : R {
&nbsp;        val catchOutboundRet = catchOutbound(catchingType, f)
&nbsp;        val server2ClientMessage = Server2ClientMessage(sessionId, catchOutboundRet.first)
&nbsp;        kweb.sendMessage(sessionId, server2ClientMessage)
&nbsp;        return catchOutboundRet.second
&nbsp;    }
&nbsp;
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
&nbsp;    internal fun &lt;P : KwebPlugin&gt; plugin(plugin: KClass&lt;out P&gt;): P {
&nbsp;        return (plugins[plugin] ?: error(&quot;Plugin $plugin is missing&quot;)) as P
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that a specific plugin be provided in [Kweb.plugins], throws an exception if not.
&nbsp;     */
&nbsp;    internal fun require(vararg requiredPlugins: KClass&lt;out KwebPlugin&gt;) {
&nbsp;        val missing = HashSet&lt;String&gt;()
&nbsp;        for (requiredPlugin in requiredPlugins) {
&nbsp;            if (!plugins.contains(requiredPlugin)) missing.add(requiredPlugin.simpleName ?: requiredPlugin.jvmName)
&nbsp;        }
&nbsp;        if (missing.isNotEmpty()) {
&nbsp;            error(&quot;Plugin(s) ${missing.joinToString(separator = &quot;, &quot;)} required but not passed to Kweb constructor&quot;)
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    data class FuncDeclaration(val js: String, val params: String)
&nbsp;    /**
&nbsp;     * this function substitutes &quot;{}&quot; in user supplied javascript, for randomly generated variable names
&nbsp;     */
&nbsp;    private fun makeJsFunction(rawJs: String): FuncDeclaration {
&nbsp;        val stringBuilder = StringBuilder()
&nbsp;        var variableCount = 1
&nbsp;        val params = mutableListOf&lt;String&gt;()
&nbsp;        var i = 0
&nbsp;        while (i &lt; rawJs.length) {
&nbsp;            if (rawJs[i] == &#39;{&#39; &amp;&amp; rawJs[i+1] == &#39;}&#39;){
&nbsp;                val jsVarName = &quot;auto_var_$variableCount&quot;
&nbsp;                stringBuilder.append(jsVarName)
&nbsp;                params.add(jsVarName)
&nbsp;                variableCount++
&nbsp;                i++//Since we matched the right bracket, we have to do an extra increment here,
&nbsp;            // to avoid checking the right bracket a second time.
&nbsp;            } else {
&nbsp;                stringBuilder.append(rawJs[i])
&nbsp;            }
&nbsp;            i++
&nbsp;        }
&nbsp;        return FuncDeclaration(stringBuilder.toString(), params.joinToString(separator = &quot;,&quot;))
&nbsp;    }
&nbsp;
&nbsp;    private fun generateCacheId() : Int {
&nbsp;        return abs(random.nextInt())
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calls a JavaScript function in the browser passing it the supplied parameters, which
&nbsp;     * will be substituted into [jsBody] wherever a `{}` is present.
&nbsp;     *
&nbsp;     * Notes:
&nbsp;     * * The `{}` will be replaced by a variable so `&quot;one {} three&quot;` won&#39;t work, use &#39;&quot;one &quot; + {} + &quot; three&quot;&#39;
&nbsp;     *   instead.
&nbsp;     * * If your JavaScript needs to use an empty JavaScript object, just insert a space
&nbsp;     *   between the {}s, eg. `{ }` so it won&#39;t be treated as a parameter
&nbsp;     */
&nbsp;    fun callJsFunction(jsBody: String, vararg args: JsonElement) {
&nbsp;        val functionCall  = if (cachedFunctions[jsBody] != null) {
&nbsp;            FunctionCall(jsId = cachedFunctions[jsBody], arguments = listOf(*args))
&nbsp;        } else {
&nbsp;            val cacheId = generateCacheId()
&nbsp;            val func = makeJsFunction(jsBody)
&nbsp;            //we add the user&#39;s unmodified js as a key and the cacheId as it&#39;s value in the hashmap
&nbsp;            cachedFunctions[jsBody] = cacheId
&nbsp;            //we send the modified js to the client to be cached there.
&nbsp;            //we don&#39;t cache the modified js on the server, because then we&#39;d have to modify JS on the server, everytime we want to check the server&#39;s cache
&nbsp;            FunctionCall(jsId = cacheId, js = func.js, parameters = func.params,
&nbsp;                    arguments = listOf(*args))
&nbsp;        }
&nbsp;        val debugInfo: DebugInfo? = if(!kweb.debug) null else {
&nbsp;            DebugInfo(jsBody, &quot;executing&quot;, Throwable())
&nbsp;        }
&nbsp;        val outboundMessageCatcher = outboundMessageCatcher.get()
&nbsp;        if (outboundMessageCatcher == null) {
&nbsp;            kweb.callJs(sessionId, functionCall, debugInfo)
&nbsp;        } else {
&nbsp;            logger.debug(&quot;Temporarily storing message for $sessionId in threadlocal outboundMessageCatcher&quot;)
&nbsp;            outboundMessageCatcher.functionList.add(functionCall)
&nbsp;            //If we are collecting calls for an immediate event, we run the risk of the client calling JS code that has yet to be cached
&nbsp;            //A functionCall object having a non null js parameter, means the function has not been cached.
&nbsp;            //So we directly execute a line of JS code that will cache the function object, using JS generated by createCacheFunctionJs
&nbsp;            if (outboundMessageCatcher.catcherType == CatcherType.IMMEDIATE_EVENT) {
&nbsp;                if (functionCall.js != null) {
&nbsp;                    val cacheJs = createCacheFunctionJs(functionCall.jsId!!, functionCall.js, functionCall.parameters)
&nbsp;                    kweb.callJs(sessionId, FunctionCall(jsId = null, js = cacheJs), null)
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun callJsFunction_sample() {
&nbsp;        callJsFunction(&quot;alert({});&quot;, JsonPrimitive(&quot;Hello, I&#39;m an alert box!&quot;))
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calls a JavaScript function that can return a value via a [callback]
&nbsp;     *
&nbsp;     * @see callJsFunction
&nbsp;     */
&nbsp;    fun callJsFunctionWithCallback(jsBody: String, callbackId: Int, callback: (JsonElement) -&gt; Unit, vararg args: JsonElement) {
&nbsp;        val functionCall = if (cachedFunctions[jsBody] != null) {
&nbsp;            FunctionCall(jsId = cachedFunctions[jsBody], arguments = listOf(*args), callbackId = callbackId)
&nbsp;        } else {
&nbsp;            val cacheId = generateCacheId()
&nbsp;            val func = makeJsFunction(jsBody)
&nbsp;            //we add the user&#39;s unmodified js as a key and the cacheId as it&#39;s value in the hashmap
&nbsp;            cachedFunctions[jsBody] = cacheId
&nbsp;            //we send the modified js to the client to be cached there.
&nbsp;            //we don&#39;t cache the modified js on the server, because then we&#39;d have to modify JS on the server, everytime we want to check the server&#39;s cache
&nbsp;            FunctionCall(jsId = cacheId, js = func.js, parameters = func.params,
&nbsp;                    arguments = listOf(*args), callbackId = callbackId)
&nbsp;        }
&nbsp;        val debugInfo: DebugInfo? = if(!kweb.debug) null else {
&nbsp;            DebugInfo(jsBody, &quot;executing&quot;, Throwable())
&nbsp;        }
&nbsp;        val outboundMessageCatcher = outboundMessageCatcher.get()
&nbsp;        if (outboundMessageCatcher == null) {
&nbsp;            kweb.callJs(sessionId, functionCall, debugInfo)
&nbsp;        } else {
&nbsp;            logger.debug(&quot;Temporarily storing message for $sessionId in threadlocal outboundMessageCatcher&quot;)
&nbsp;            outboundMessageCatcher.functionList.add(functionCall)
&nbsp;            if (outboundMessageCatcher.catcherType == CatcherType.IMMEDIATE_EVENT) {
&nbsp;                if (functionCall.js != null) {
&nbsp;                    val cacheJs = createCacheFunctionJs(functionCall.jsId!!, functionCall.js, functionCall.parameters)
&nbsp;                    kweb.callJs(sessionId, FunctionCall(jsId = null, js = cacheJs), null)
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        kweb.addCallback(sessionId, functionCall.callbackId!!, callback)
&nbsp;    }
&nbsp;
&nbsp;    fun addCloseListener(listener: () -&gt; Unit) : Int {
&nbsp;        val id = random.nextInt()
&nbsp;        this.closeListeners[id] = listener
&nbsp;        return id
&nbsp;    }
&nbsp;
&nbsp;    fun removeCloseListener(id: Int) {
&nbsp;        synchronized(this) {
&nbsp;            this.closeListeners.remove(id)
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun close() {
&nbsp;        synchronized(this) {
&nbsp;            try {
&nbsp;                this.closeListeners.values.forEach { it() }
&nbsp;            } catch (e : Exception) {
&nbsp;                logger.warn(&quot;Exception while calling closeListener&quot;, e)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun createCacheFunctionJs(cacheId: Int, functionBody: String, params: String? = null) : String {
&nbsp;        params?.let {
&nbsp;            //language=JavaScript
&nbsp;            return &quot;&quot;&quot;cachedFunctions[$cacheId] = new Function(&quot;$params&quot;, &quot;$functionBody&quot;);&quot;&quot;&quot;
&nbsp;        }
&nbsp;        //language=JavaScript
&nbsp;        return &quot;&quot;&quot;cachedFunctions[$cacheId] = new Function(&quot;$functionBody&quot;);&quot;&quot;&quot;
&nbsp;    }
&nbsp;
&nbsp;    fun removeCallback(callbackId: Int) {
&nbsp;        kweb.removeCallback(sessionId, callbackId)
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calls a JavaScript function that can return a value, note that to do this [jsBody] **MUST** end with
&nbsp;     * a `return` statement, eg:
&nbsp;     *
&nbsp;     * ```kotlin
&nbsp;     *   val result = callJsFunctionWithResult(&quot;return 1 + 1&quot;)
&nbsp;     * ```
&nbsp;     */
&nbsp;    suspend fun callJsFunctionWithResult(jsBody: String, vararg args: JsonElement): JsonElement {
&nbsp;        require(isCatchingOutbound() == null) {
&nbsp;            &quot;You can not read the DOM inside a batched code block&quot;
&nbsp;        }
&nbsp;        val callbackId = abs(random.nextInt())
&nbsp;        val cd = CompletableDeferred&lt;JsonElement&gt;()
&nbsp;        callJsFunctionWithCallback(jsBody, callbackId = callbackId, callback = { response -&gt;
&nbsp;            cd.complete(response)
&nbsp;        }, *args)
&nbsp;        return cd.await()
&nbsp;    }
&nbsp;
&nbsp;    val doc = Document(this)
&nbsp;
&nbsp;    val window = Window(this)
&nbsp;
&nbsp;    private data class UrlSource(val url : String, val source : Source) {
&nbsp;        enum class Source {
&nbsp;            Initial, Client, Server
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * We must keep track of whether a URL change was initiated on the client or on the
&nbsp;     * server to avoid unnecessarily pushing a new URL state back to the client when
&nbsp;     * that&#39;s where it originated.
&nbsp;     *
&nbsp;     * Suspect this was the cause of https://github.com/kwebio/kweb-core/issues/219
&nbsp;     */
&nbsp;    private val urlSource : KVar&lt;UrlSource&gt; by lazy {
&nbsp;        val originRelativeURL = URL.parse(httpRequestInfo.requestedUrl).pathQueryFragment
&nbsp;        val urlSource = KVar(UrlSource(originRelativeURL, UrlSource.Source.Initial))
&nbsp;
&nbsp;        urlSource.addListener { oldState, newState -&gt;
&nbsp;            logger.debug { &quot;urlSource $oldState -&gt; $newState&quot; }
&nbsp;            if (newState.source == UrlSource.Source.Server) {
&nbsp;                pushState(newState.url)
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        window.on(
&nbsp;            //language=JavaScript
&nbsp;            retrieveJs = &quot;window.location.href&quot;
&nbsp;        ).popstate { event : Event -&gt;
&nbsp;            if (event.retrieved is JsonPrimitive &amp;&amp; event.retrieved.isString) {
&nbsp;                urlSource.value = UrlSource(
&nbsp;                    URL.parse(event.retrieved.content).pathQueryFragment,
&nbsp;                    UrlSource.Source.Client
&nbsp;                )
&nbsp;            } else {
&nbsp;                error(&quot;event.retrieved isn&#39;t a string&quot;)
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        urlSource
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The URL of the page, relative to the origin - so for the page `http://foo/bar?baz#1`, the value would be
&nbsp;     * `/bar?baz#1`.
&nbsp;     *
&nbsp;     * When this KVar is modified the browser will automatically update the URL in the browser along with any DOM
&nbsp;     * elements based on this [url] (this will be handled automatically by [kweb.routing.route]).
&nbsp;     *
&nbsp;     * If the [popstate event](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) fires
&nbsp;     * in the browser, for example if the Back button is pressed, then this URL will also update - potentially
&nbsp;     * triggering re-renders of any DOM elements that depend on the URL.
&nbsp;     */
&nbsp;    val url: KVar&lt;String&gt;
&nbsp;            by lazy {
&nbsp;                urlSource.map(object : ReversibleFunction&lt;UrlSource, String&gt;(&quot;urlSource&quot;) {
&nbsp;                    override fun invoke(from: UrlSource) = from.url
&nbsp;                    override fun reverse(original: UrlSource, change: String) =
&nbsp;                        if (change != original.url) {
&nbsp;                            UrlSource(change, UrlSource.Source.Server)
&nbsp;                        } else {
&nbsp;                            UrlSource(change, original.source)
&nbsp;                        }
&nbsp;                })
&nbsp;            }
&nbsp;
&nbsp;    private fun pushState(url: String) {
&nbsp;        if (!url.startsWith(&#39;/&#39;)) {
&nbsp;            logger.warn(&quot;pushState should only be called with origin-relative URLs (ie. they should start with a /)&quot;)
&nbsp;        }
&nbsp;        //{ } is used to initialize an empty map here. Without the space, it would be treated
&nbsp;        //as a variable using Kweb&#39;s template syntax
&nbsp;        //language=JavaScript
&nbsp;        callJsFunction(&quot;&quot;&quot;
&nbsp;        history.pushState({ }, &quot;&quot;, {});
&nbsp;        &quot;&quot;&quot;.trimIndent(), JsonPrimitive(url))
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The absolute URL of the page, mapped to a [io.mola.galimatias.URL](http://galimatias.mola.io/apidocs/0.2.0/io/mola/galimatias/URL.html) for convenience.
&nbsp;     */
&nbsp;    val gurl : KVar&lt;URL&gt; = url.map(object : ReversibleFunction&lt;String, URL&gt;(label = &quot;gurl&quot;) {
&nbsp;        override fun invoke(from: String): URL {
&nbsp;            return URL.parse(this@WebBrowser.httpRequestInfo.requestedUrl).resolve(from)
&nbsp;        }
&nbsp;
&nbsp;        override fun reverse(original: String, change: URL): String {
&nbsp;            return change.pathQueryFragment
&nbsp;        }
&nbsp;    } )
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-12-21 05:23</div>
</div>
</body>
</html>
