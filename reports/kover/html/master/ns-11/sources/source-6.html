


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ObservableList</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">kweb.state</a>
</div>

<h1>Coverage Summary for Class: ObservableList (kweb.state)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">ObservableList</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (24/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.2%
  </span>
  <span class="absValue">
    (24/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.7%
  </span>
  <span class="absValue">
    (77/119)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.1%
  </span>
  <span class="absValue">
    (444/633)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ObservableList$listIterator$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (27/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObservableList$Modification</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObservableList$Modification$Change</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObservableList$Modification$Deletion</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObservableList$Modification$Insertion</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObservableList$Modification$Move</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (33/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.2%
  </span>
  <span class="absValue">
    (24/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.2%
  </span>
  <span class="absValue">
    (86/128)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (520/709)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package kweb.state
&nbsp;
&nbsp;import java.util.concurrent.ConcurrentHashMap
&nbsp;
&nbsp;/**
&nbsp; * A list of items that can be observed for changes like [add], [remove], [set], etc. Typically passed to
&nbsp; * [renderEach].
&nbsp; */
<b class="fc">&nbsp;class ObservableList&lt;ITEM : Any&gt;(</b>
<b class="nc">&nbsp;    initialItems: List&lt;ITEM&gt; = emptyList(),</b>
&nbsp;) : MutableList&lt;ITEM&gt;, AutoCloseable {
&nbsp;
<b class="fc">&nbsp;    private val items = ArrayList(initialItems)</b>
&nbsp;    fun getItems(): ArrayList&lt;ITEM&gt; {
<b class="fc">&nbsp;        synchronized(items) {</b>
<b class="fc">&nbsp;            return ArrayList(items)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private val listeners = ConcurrentHashMap&lt;Long, (Iterable&lt;Modification&lt;ITEM&gt;&gt;) -&gt; Unit&gt;()</b>
&nbsp;
<b class="fc">&nbsp;    private val closeListeners = HashMap&lt;Long, () -&gt; Unit&gt;()</b>
<b class="fc">&nbsp;    private fun insert(position: Int, item: ITEM) = applyModifications(listOf(Modification.Insertion(position, item)))</b>
&nbsp;    private fun change(position: Int, newItem: ITEM) =
<b class="fc">&nbsp;        applyModifications(listOf(Modification.Change(position, newItem)))</b>
&nbsp;
<b class="fc">&nbsp;    private fun delete(position: Int) = applyModifications(listOf(Modification.Deletion(position)))</b>
&nbsp;
<b class="fc">&nbsp;    override val size: Int get() = items.size</b>
&nbsp;
&nbsp;    fun move(oldPosition: Int, newPosition: Int) =
<b class="fc">&nbsp;        applyModifications(listOf(Modification.Move(oldPosition, newPosition)))</b>
&nbsp;
&nbsp;    fun applyModifications(modifications: Iterable&lt;Modification&lt;ITEM&gt;&gt;) {
<b class="pc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot modify closed ObservableList&quot;)</b>
&nbsp;        }
<b class="fc">&nbsp;        synchronized(items) {</b>
<b class="fc">&nbsp;            for (change in modifications) {</b>
<b class="fc">&nbsp;                when (change) {</b>
<b class="fc">&nbsp;                    is Modification.Change -&gt; {</b>
<b class="fc">&nbsp;                        items[change.position] = change.newItem</b>
&nbsp;                    }
<b class="fc">&nbsp;                    is Modification.Deletion -&gt; {</b>
<b class="fc">&nbsp;                        items.removeAt(change.position)</b>
&nbsp;                    }
<b class="fc">&nbsp;                    is Modification.Insertion -&gt; {</b>
<b class="fc">&nbsp;                        items.add(change.position, change.item)</b>
&nbsp;                    }
<b class="pc">&nbsp;                    is Modification.Move -&gt; {</b>
<b class="pc">&nbsp;                        if (change.oldPosition == change.newPosition) {</b>
<b class="nc">&nbsp;                            continue</b>
&nbsp;                        }
<b class="fc">&nbsp;                        val item = items[change.oldPosition]</b>
<b class="fc">&nbsp;                        if (change.oldPosition &gt;= change.newPosition) {</b>
<b class="fc">&nbsp;                            items.add(change.newPosition, item)</b>
<b class="fc">&nbsp;                            items.removeAt(change.oldPosition + 1)</b>
<b class="fc">&nbsp;                            println(&quot;Items size: ${items.size}&quot;)</b>
&nbsp;                        } else { //change.newPosition &gt; change.oldPosition
<b class="fc">&nbsp;                            items.removeAt(change.oldPosition)</b>
<b class="fc">&nbsp;                            items.add(change.newPosition, item)</b>
<b class="fc">&nbsp;                            println(</b>
<b class="fc">&nbsp;                                &quot;Items size: ${items.size}&quot; +</b>
<b class="fc">&nbsp;                                        &quot;\nItems Contents: $items&quot;</b>
&nbsp;                            )
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        listeners.values.forEach { it(modifications) }</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    sealed class Modification&lt;ITEM&gt; {</b>
<b class="fc">&nbsp;        class Insertion&lt;ITEM&gt;(val position: Int, val item: ITEM) : Modification&lt;ITEM&gt;()</b>
<b class="fc">&nbsp;        class Change&lt;ITEM&gt;(val position: Int, val newItem: ITEM) : Modification&lt;ITEM&gt;()</b>
<b class="fc">&nbsp;        class Move&lt;ITEM&gt;(val oldPosition: Int, val newPosition: Int) : Modification&lt;ITEM&gt;()</b>
<b class="fc">&nbsp;        class Deletion&lt;ITEM&gt;(val position: Int) : Modification&lt;ITEM&gt;()</b>
&nbsp;    }
&nbsp;
&nbsp;    fun addListener(changes: (Iterable&lt;Modification&lt;ITEM&gt;&gt;) -&gt; Unit): Long {
<b class="pc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot add listener to closed ObservableList&quot;)</b>
&nbsp;        }
<b class="fc">&nbsp;        val handle = kweb.util.random.nextLong()</b>
<b class="fc">&nbsp;        listeners[handle] = changes</b>
<b class="fc">&nbsp;        return handle</b>
&nbsp;    }
&nbsp;
&nbsp;    fun removeListener(handle: Long) {
<b class="pc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot remove listener from closed ObservableList&quot;)</b>
&nbsp;        }
<b class="fc">&nbsp;        listeners.remove(handle)</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun contains(element: ITEM): Boolean {
<b class="nc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot read closed ObservableList&quot;)</b>
&nbsp;        }
<b class="nc">&nbsp;        return items.contains(element)</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun containsAll(elements: Collection&lt;ITEM&gt;): Boolean {
<b class="nc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot read closed ObservableList&quot;)</b>
&nbsp;        }
<b class="nc">&nbsp;        return items.containsAll(elements)</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun get(index: Int): ITEM {
<b class="pc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot read closed ObservableList&quot;)</b>
&nbsp;        }
<b class="fc">&nbsp;        return items[index]</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun indexOf(element: ITEM): Int {
<b class="nc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot read closed ObservableList&quot;)</b>
&nbsp;        }
<b class="nc">&nbsp;        return items.indexOf(element)</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun isEmpty(): Boolean {
<b class="pc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot read closed ObservableList&quot;)</b>
&nbsp;        }
<b class="fc">&nbsp;        return items.isEmpty()</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an iterator over the elements in this list (in proper sequence).
&nbsp;     *
&nbsp;     * **IMPORTANT:** The returned iterator will throw an UnsupportedOperationException
&nbsp;     * if you attempt to call [MutableIterator.remove].
&nbsp;     */
&nbsp;    override fun iterator(): MutableIterator&lt;ITEM&gt; {
<b class="fc">&nbsp;        return listIterator()</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun lastIndexOf(element: ITEM): Int {
<b class="nc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot read closed ObservableList&quot;)</b>
&nbsp;        }
<b class="nc">&nbsp;        return items.lastIndexOf(element)</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun add(element: ITEM): Boolean {
&nbsp;
<b class="fc">&nbsp;        insert(items.size, element)</b>
<b class="fc">&nbsp;        return true</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun add(index: Int, element: ITEM) {
<b class="fc">&nbsp;        insert(index, element)</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun addAll(index: Int, elements: Collection&lt;ITEM&gt;): Boolean {
<b class="nc">&nbsp;        for ((i, element) in elements.withIndex()) {</b>
<b class="nc">&nbsp;            insert(index + i, element)</b>
&nbsp;        }
<b class="nc">&nbsp;        return true</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun addAll(elements: Collection&lt;ITEM&gt;): Boolean {
<b class="nc">&nbsp;        elements.forEach { element -&gt;</b>
<b class="nc">&nbsp;            insert(items.size, element)</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return true</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun clear() {
<b class="fc">&nbsp;        while (items.size &gt; 0) {</b>
<b class="fc">&nbsp;            delete(0)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list iterator over the elements in this list (in proper sequence).
&nbsp;     *
&nbsp;     * **IMPORTANT:** The returned iterator will throw an UnsupportedOperationException
&nbsp;     * if you attempt to call [MutableListIterator.add], [MutableListIterator.set], or
&nbsp;     * [MutableListIterator.remove]. Implementing these in a threadsafe manner is
&nbsp;     * difficult, and they are not needed for the intended use of this class.
&nbsp;     */
<b class="fc">&nbsp;    override fun listIterator(): MutableListIterator&lt;ITEM&gt; = listIterator(0)</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list iterator over the elements in this list (in proper sequence),
&nbsp;     * starting at the specified position.
&nbsp;     *
&nbsp;     * **IMPORTANT:** The returned iterator will throw an UnsupportedOperationException
&nbsp;     * if you attempt to call [MutableListIterator.add], [MutableListIterator.set], or
&nbsp;     * [MutableListIterator.remove]. Implementing these in a threadsafe manner is
&nbsp;     * difficult, and they are not needed for the intended use of this class.
&nbsp;     */
&nbsp;    override fun listIterator(index: Int): MutableListIterator&lt;ITEM&gt; {
<b class="pc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot read closed ObservableList&quot;)</b>
&nbsp;        }
&nbsp;        // Clone the list so that we can iterate over it without worrying about
&nbsp;        // concurrent modification. Disallow modifications to the list because
&nbsp;        // allowing this in a threadsafe way would be non-trivial for questionable
&nbsp;        // benefit.
&nbsp;
<b class="fc">&nbsp;        return object : MutableListIterator&lt;ITEM&gt; by ArrayList(items).listIterator(index) {</b>
&nbsp;            override fun set(element: ITEM) {
<b class="fc">&nbsp;                throw UnsupportedOperationException(&quot;Cannot set element via iterator in ObservableList&quot;)</b>
&nbsp;            }
&nbsp;
&nbsp;            override fun add(element: ITEM) {
<b class="fc">&nbsp;                throw UnsupportedOperationException(&quot;Cannot add element via iterator to ObservableList&quot;)</b>
&nbsp;            }
&nbsp;
&nbsp;            override fun remove() {
<b class="fc">&nbsp;                throw UnsupportedOperationException(&quot;Cannot remove element via iterator from ObservableList&quot;)</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    override fun remove(element: ITEM): Boolean {
<b class="fc">&nbsp;        val position = items.indexOf(element)</b>
<b class="pc">&nbsp;        return if (position == -1) {</b>
<b class="nc">&nbsp;            false</b>
&nbsp;        } else {
<b class="fc">&nbsp;            delete(position)</b>
<b class="fc">&nbsp;            true</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    override fun removeAll(elements: Collection&lt;ITEM&gt;): Boolean {
<b class="nc">&nbsp;        var removed = false</b>
<b class="nc">&nbsp;        for (element in elements) {</b>
<b class="nc">&nbsp;            if (remove(element)) {</b>
<b class="nc">&nbsp;                removed = true</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return removed</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun removeAt(index: Int): ITEM {
<b class="pc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot modify closed ObservableList&quot;)</b>
&nbsp;        }
<b class="fc">&nbsp;        val itemToRemove = items[index]</b>
<b class="fc">&nbsp;        delete(index)</b>
<b class="fc">&nbsp;        return itemToRemove</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun retainAll(elements: Collection&lt;ITEM&gt;): Boolean {
<b class="nc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot modify closed ObservableList&quot;)</b>
&nbsp;        }
<b class="nc">&nbsp;        items.clear()</b>
<b class="nc">&nbsp;        addAll(elements)</b>
<b class="nc">&nbsp;        return true</b>
&nbsp;    }
&nbsp;
&nbsp;    override operator fun set(index: Int, element: ITEM): ITEM {
<b class="pc">&nbsp;        if (closed) {</b>
<b class="nc">&nbsp;            throw IllegalStateException(&quot;Cannot set element of closed ObservableList&quot;)</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        val previousElement = items[index]</b>
<b class="fc">&nbsp;        change(index, element)</b>
<b class="fc">&nbsp;        return previousElement</b>
&nbsp;    }
&nbsp;
&nbsp;    //TODO: Documentation will need a note explaining that any modifications to the returned sublist will not propagate in the DOM
&nbsp;    override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;ITEM&gt; {
<b class="fc">&nbsp;        return items.subList(fromIndex, toIndex)</b>
&nbsp;    }
&nbsp;
&nbsp;    private @Volatile
&nbsp;    var closed = false
&nbsp;
&nbsp;    fun addCloseListener(listener: () -&gt; Unit): Long {
<b class="fc">&nbsp;        val handle = kweb.util.random.nextLong()</b>
<b class="fc">&nbsp;        synchronized(closeListeners) {</b>
<b class="fc">&nbsp;            closeListeners[handle] = listener</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return handle</b>
&nbsp;    }
&nbsp;
&nbsp;    fun removeCloseListener(handle: Long) {
<b class="nc">&nbsp;        synchronized(closeListeners) {</b>
<b class="nc">&nbsp;            closeListeners.remove(handle)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    override fun close() {
<b class="pc">&nbsp;        if (!closed) {</b>
<b class="fc">&nbsp;            closed = true</b>
<b class="fc">&nbsp;            synchronized(closeListeners) {</b>
<b class="fc">&nbsp;                closeListeners.values.forEach { it() }</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-12-04 19:10</div>
</div>
</body>
</html>
