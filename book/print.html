<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Kweb User Manual</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="User manual for the Kweb web framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="gettingstarted.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="dom.html"><strong aria-hidden="true">3.</strong> DOM Basics</a></li><li class="chapter-item expanded "><a href="events.html"><strong aria-hidden="true">4.</strong> Event Handling</a></li><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">5.</strong> Observer Pattern & State</a></li><li class="chapter-item expanded "><a href="routing.html"><strong aria-hidden="true">6.</strong> URL Routing</a></li><li class="chapter-item expanded "><a href="style.html"><strong aria-hidden="true">7.</strong> CSS & Style</a></li><li class="chapter-item expanded "><a href="components.html"><strong aria-hidden="true">8.</strong> Components</a></li><li class="chapter-item expanded "><a href="js.html"><strong aria-hidden="true">9.</strong> JavaScript Interop</a></li><li class="chapter-item expanded "><a href="speed.html"><strong aria-hidden="true">10.</strong> Speed & Efficiency</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">11.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Kweb User Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/kwebio/kweb-core" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>https://ktor.io/# Introduction</p>
<h2 id="why-another-web-framework"><a class="header" href="#why-another-web-framework">Why another web framework?</a></h2>
<p>Modern websites consist of at least two <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">tightly
coupled</a>
components, one runs in the browser, the other on the server. These are
often written in different programming languages and must communicate
with each other over an HTTP(S) connection.</p>
<p>Kweb's goal is to eliminate this server/browser separation so you can
focus on building your website or user interface, not on the plumbing.</p>
<h2 id="what-is-kweb"><a class="header" href="#what-is-kweb">What is Kweb?</a></h2>
<p>Kweb is a remote interface to a web browser's DOM. With Kweb, you can create 
and manipulate DOM elements, and bind mutable values to DOM elements, and listen for 
and handle events. All of this can be done using an intuitive and convenient domain-specific 
language that mirrors the structure of the HTML being created. </p>
<p>Kweb is very efficient, using many <a href="speed.html">optimizations</a> to minimize latency and resource 
usage both on the server and in the browser. Kweb is built on the <a href="https://ktor.io/">Ktor</a> 
framework, which handles HTTP, HTTPS, and WebSocket transport.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>
<p>End-to-end Kotlin - write your entire web site or user interface in Kotlin, without needing to communicate between a browser and server (<a href="https://steve-yegge.blogspot.com/2017/05/why-kotlin-is-better-than-whatever-dumb.html?m=1">Why
Kotlin?</a>)</p>
</li>
<li>
<p>Realtime synchronization of your back-end data with your web page - Kweb takes care of all the plumbing for you</p>
</li>
<li>
<p>Server-side HTML rendering with <a href="https://en.wikipedia.org/wiki/Hydration_(web_development)">hydration</a>, Kweb can render your HTML on the server before sending it to the browser, so that the browser doesn't have to do any rendering</p>
</li>
<li>
<p>Efficient instruction preloading - Kweb can avoid unnecessary server communication by preloading instructions</p>
</li>
<li>
<p>Very lightweight - Kweb is less than 5,000 lines of code</p>
</li>
</ul>
<h2 id="relevant-links"><a class="header" href="#relevant-links">Relevant Links</a></h2>
<ul>
<li><a href="https://github.com/kwebio/kweb-core">Github repository</a></li>
<li><a href="https://docs.kweb.io/api/">API documentation</a></li>
<li><a href="https://github.com/freenet/freenetorg-website/">Example Google Cloud Project</a></li>
<li><a href="https://github.com/kwebio/kweb-core/issues">Questions/Feedback/Bugs</a></li>
<li>Chat with us on <a href="https://matrix.to/#/#kweb:matrix.org">Matrix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<ul>
<li><a href="gettingstarted.html#requirements">Requirements</a></li>
<li><a href="gettingstarted.html#adding-kweb-to-your-gradle-project">Adding Kweb to your Gradle project</a>
<ul>
<li><a href="gettingstarted.html#groovy">Groovy</a></li>
<li><a href="gettingstarted.html#kotlin">Kotlin</a></li>
</ul>
</li>
<li><a href="gettingstarted.html#hello-world">Hello world</a></li>
<li><a href="gettingstarted.html#hello-world%C2%B2">Hello world²</a></li>
<li><a href="gettingstarted.html#template-repository">Template Repository</a></li>
</ul>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Some familiarity with <a href="https://kotlinlang.org/">Kotlin</a> is assumed, as
is familiarity with <a href="https://gradle.org/">Gradle</a>. You should also have
some familiarity with HTML.</p>
<h2 id="adding-kweb-to-your-gradle-project"><a class="header" href="#adding-kweb-to-your-gradle-project">Adding Kweb to your Gradle project</a></h2>
<p>Add these to your dependencies in your <code>build.gradle</code> or <code>build.gradle.kt</code> files, ensure <code>mavenCentral()</code> 
is added to your <code>repositories</code> block.</p>
<h3 id="groovy"><a class="header" href="#groovy">Groovy</a></h3>
<pre><code class="language-kotlin">dependencies {
  implementation 'io.kweb:kweb-core:1.1.5'

  // This (or another SLF4J binding) is required for Kweb to log errors
  implementation 'org.slf4j:slf4j-simple:2.0.3'
}
</code></pre>
<h3 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h3>
<pre><code class="language-kotlin">dependencies {
  implementation(&quot;io.kweb:kweb-core:1.1.5&quot;)

  // This (or another SLF4J binding) is required for Kweb to log errors
  implementation(&quot;org.slf4j:slf4j-simple:2.0.3&quot;)
}
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h2>
<p>Create a new Kotlin file and type this:</p>
<pre><code class="language-kotlin">import kweb.*

fun main() {
    Kweb(port = 16097) {
        doc.body {
            h1().text(&quot;Hello World!&quot;)
        }
    }
}
</code></pre>
<p>Run it, and then visit <a href="http://localhost:16097/">http://localhost:16097/</a> in your web browser to
see the traditional greeting, translating to the following HTML body:</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;/body&gt;
</code></pre>
<p>This simple example already illustrates some important features of Kweb:</p>
<ul>
<li>Getting a kwebsite up and running is a breeze, no messing around
with servlets, or third party webservers</li>
<li>Your Kweb code will loosely mirror the structure of the HTML it
generates</li>
</ul>
<h2 id="hello-world²"><a class="header" href="#hello-world²">Hello world²</a></h2>
<p>One way to think of Kweb is as a <a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain-specific language
(DSL)</a> for
building and manipulating a
<a href="https://en.wikipedia.org/wiki/Document_Object_Model">DOM</a> in a remote
web browser, while also listening for and handing DOM events.</p>
<p>Importantly, this DSL can also do anything Kotlin can do, including
features like for loops, functions, coroutines, and classes.</p>
<p>Here is a simple example using an ordinary Kotlin <em>for loop</em>:</p>
<pre><code class="language-kotlin">Kweb(port = 16097) {
    doc.body {
        ul {
            for (x in 1..5) {
                li().text(&quot;Hello World $x!&quot;)
            }
        }
    }
}
</code></pre>
<p>To produce...</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;ul&gt;
      &lt;li&gt;Hello World 1!&lt;/li&gt;
      &lt;li&gt;Hello World 2!&lt;/li&gt;
      &lt;li&gt;Hello World 3!&lt;/li&gt;
      &lt;li&gt;Hello World 4!&lt;/li&gt;
      &lt;li&gt;Hello World 5!&lt;/li&gt;
  &lt;/ul&gt;
&lt;/body&gt;
</code></pre>
<h2 id="template-repository"><a class="header" href="#template-repository">Template Repository</a></h2>
<p>You can find a simple template Kweb project in
<a href="https://github.com/kwebio/kweb-template">kwebio/kweb-template</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dom-basics"><a class="header" href="#dom-basics">DOM Basics</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="dom.html#creating-dom-elements-and-fragments">Creating DOM Elements and Fragments</a></li>
<li><a href="dom.html#element-attributes">Element Attributes</a></li>
<li><a href="dom.html#adding-children-to-an-existing-element">Adding children to an existing element</a></li>
<li><a href="dom.html#reading-from-the-dom">Reading from the DOM</a></li>
<li><a href="dom.html#supported-html-tags">Supported HTML tags</a></li>
<li><a href="dom.html#further-reading">Further Reading</a></li>
</ul>
<h2 id="creating-dom-elements-and-fragments"><a class="header" href="#creating-dom-elements-and-fragments">Creating DOM Elements and Fragments</a></h2>
<p>Let's create a <code>&lt;button&gt;</code> as a child of the <code>&lt;body&gt;</code> element and set its <a href="https://docs.kweb.io/api/kweb-core/kweb/-element/text.html">text</a>:</p>
<pre><code class="language-kotlin">fun main() {
    Kweb(port = 16097) {
        doc.body {
            button().text(&quot;Click Me!&quot;)
        }
    }
}
</code></pre>
<p>The Kweb DSL can be used to create nested elements:</p>
<pre><code class="language-kotlin">Kweb(port = 16097) {
    doc.body {
        table {
            tr {
                th().text(&quot;Name&quot;)
                th().text(&quot;Age&quot;)
            }
            tr {
                td().text(&quot;Alice&quot;)
                td().text(&quot;21&quot;)
            }
            tr {
                td().text(&quot;Bob&quot;)
                td().text(&quot;22&quot;)
            }
        }
    }
}
</code></pre>
<h2 id="element-attributes"><a class="header" href="#element-attributes">Element Attributes</a></h2>
<p>If you assign the button element to a val then you can also <a href="https://docs.kweb.io/api/kweb-core/kweb/-element/set.html">set its
attributes</a>:</p>
<pre><code class="language-kotlin">val button = button()
button.text(&quot;Click Me!&quot;)
button.classes(&quot;bigbutton&quot;)
button[&quot;autofocus&quot;] = true
</code></pre>
<p>Or delete it:</p>
<pre><code class="language-kotlin">button.delete()
</code></pre>
<h2 id="adding-children-to-an-existing-element"><a class="header" href="#adding-children-to-an-existing-element">Adding children to an existing element</a></h2>
<p>The DSL syntax makes it very easy to create elements and their children
together:</p>
<pre><code class="language-kotlin">ul {
    li().text(&quot;One&quot;)
    li().text(&quot;Two&quot;)
}
</code></pre>
<p>The created
<a href="https://docs.kweb.io/api/kweb-core/kweb/-element/index.html">Element</a> is passed to the
<code>{block}</code> as a parameter, which can be used to set attributes on the element, add
listeners, or set the element's <a href="https://docs.kweb.io/api/kweb-core/kweb/-element/text.html">text</a> or <a href="https://docs.kweb.io/api/kweb-core/kweb/-element/inner-h-t-m-l.html">innerHtml</a>:</p>
<pre><code class="language-kotlin">button { btnEl -&gt;
    with(btnEl) {
        classes(&quot;bigbutton&quot;)
        this[&quot;autofocus&quot;] = true
        text(&quot;Click Me!&quot;)
    }
}
</code></pre>
<p>We can also use the <code>new {}</code> function to add children to a pre-existing Element:</p>
<pre><code class="language-kotlin">val unorderedList : ULElement = ul()
unorderedList.new {
    li().text(&quot;One&quot;)
    li().text(&quot;Two&quot;)
}
</code></pre>
<h2 id="reading-from-the-dom"><a class="header" href="#reading-from-the-dom">Reading from the DOM</a></h2>
<p>Kweb can also read from the DOM, in this case the value of an <code>&lt;input&gt;</code>
element:</p>
<pre><code class="language-kotlin">val input: InputElement = input(type = InputType.text)
// A KVar is a mutable value to which you can add listeners
val inputKVar = input.value
inputKVar.addListener { old, new -&gt;
    println(&quot;Input changed from $old to $new&quot;)
}
</code></pre>
<p>Events can evaluate a JavaScript expression and send the result to the
server, in this case we give it an expression that will retrieve the
value of an InputElement, conveniently provided by valueJsExpression.</p>
<p><strong>Note:</strong> See the <a href="https://docs.kweb.io/book/state.html#binding-a-kvar-to-an-input-elements-value">Observer Pattern &amp;
State</a>
section for another way to read input element values.</p>
<h2 id="supported-html-tags"><a class="header" href="#supported-html-tags">Supported HTML tags</a></h2>
<p>Kweb supports a significant subset of HTML tags like <em>button()</em>, <em>p()</em>,
<em>a()</em>, <em>table()</em>, and so on. You can find a more complete list in
<a href="https://github.com/kwebio/kweb-core/blob/master/src/main/kotlin/kweb/prelude.kt">prelude.kt</a>
(scroll down to the <em>Functions</em> section). This provides a nice
statically-typed HTML DSL, fully integrated with the Kotlin language.</p>
<p>If a tag doesn't have explicit support in Kweb that's not a problem.
For example, here is how you might use the infamous and now-obsolete
&lt;blink&gt; tag:</p>
<pre><code class="language-kotlin">element(&quot;blink&quot;) {
    span().text(&quot;Blinking Text&quot;)
}
</code></pre>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<p>The
<a href="https://github.com/kwebio/kweb-core/blob/master/src/main/kotlin/kweb/Element.kt">Element</a>
class provides many other useful ways to interact with DOM elements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h1>
<ul>
<li><a href="events.html#listening-for-events">Listening for events</a></li>
<li><a href="events.html#immediate-events">Immediate events</a>
<ul>
<li><a href="events.html#using-events-and-immediate-events-together">Using events and immediate events together</a></li>
</ul>
</li>
<li><a href="events.html#querying-the-dom-when-an-event-is-triggered">Querying the DOM when an event is triggered</a></li>
<li><a href="events.html#preventing-the-default-event-action">Preventing the default event action</a></li>
</ul>
<h2 id="listening-for-events"><a class="header" href="#listening-for-events">Listening for events</a></h2>
<p>You can attach event handlers to DOM elements:</p>
<pre><code class="language-kotlin">doc.body {
    val label = h1()
    label.text(&quot;Click Me&quot;)
    label.on.click {
        label.text(&quot;Clicked!&quot;)
    }
}
</code></pre>
<p>Most if not all JavaScript event types are supported, and you can read
event data like which key was pressed:</p>
<pre><code class="language-kotlin">doc.body {
    val input = input(type = InputType.text)
    input.on.keypress { keypressEvent -&gt;
        logger.info(&quot;Key Pressed: ${keypressEvent.key}&quot;)
    }
}
</code></pre>
<h2 id="immediate-events"><a class="header" href="#immediate-events">Immediate events</a></h2>
<p>Since the code to respond to events runs on the server, there may be a
short but sometimes noticeable delay before the page updates in response
to an event.</p>
<p>Fortunately, Kweb has a solution:</p>
<pre><code class="language-kotlin">inputButton.on(retrieveJs = &quot;(new Date()).getTime()&quot;).click { event -&gt;
    label.text(&quot;Clicked at ${event.retrieved.jsonPrimitive.content}&quot;)
}
</code></pre>
<p>Kweb executes this event handler <em>on page render</em> and records the
changes it makes to the DOM. It then &quot;pre-loads&quot; these instructions to
the browser such that they are executed immediately without a server
round trip.</p>
<p><strong>Warning:</strong> Due to this pre-loading mechanism, the event handler for an
<em>onImmediate</em> must limit itself to simple DOM modifications. Kweb
includes some runtime safeguards against this but they can't catch
everything so please use with caution.</p>
<h3 id="using-events-and-immediate-events-together"><a class="header" href="#using-events-and-immediate-events-together">Using events and immediate events together</a></h3>
<p>A common pattern is to use both types of event handler on a DOM element.
The immediate handler might disable a clicked button, or temporarily
display some form of <a href="https://loading.io/css/">spinner</a>. The normal
handler would then do what it needs on the server, and then perhaps
re-enable the button and remove the spinner.</p>
<h2 id="querying-the-dom-when-an-event-is-triggered"><a class="header" href="#querying-the-dom-when-an-event-is-triggered">Querying the DOM when an event is triggered</a></h2>
<p>Sometimes you need to know the state of the DOM when an event is triggered.
You could query it from within the event handler but this would add a server 
round trip which is inefficient.</p>
<p>Alternatively you can use <a href="https://docs.kweb.io/api/kweb-core/kweb.html.events/-on-receiver/-on-receiver.html">retrieveJs</a>. 
This will execute the JavaScript expression you provide when the event fires and return the 
result in the <a href="https://docs.kweb.io/api/kweb-core/kweb.html.events/-event/retrieved.html?query=val%20retrieved:%20JsonElement">retrieved</a> property of the event:</p>
<pre><code class="language-kotlin">inputButton.on(retrieveJs = &quot;(new Date()).getTime()&quot;).click { event -&gt;
    label.text(&quot;Clicked at ${event.retrieved.jsonPrimitive.content}&quot;)
}
</code></pre>
<p>For <a href="https://docs.kweb.io/api/kweb-core/kweb/-value-element/index.html">ValueElement</a>s
such as <a href="https://docs.kweb.io/api/kweb-core/kweb/-input-element/index.html">InputElement</a>
there is a convenience property <code>valueJsExpression</code> that you can use to retrieve
the current <a href="https://www.w3schools.com/tags/att_input_value.asp">value</a> of the element:</p>
<pre><code class="language-kotlin">val textInput = input(type = InputType.text)
val inputButton = button(type = ButtonType.button)
val label = span().text(&quot;Not clicked&quot;)
inputButton.on(retrieveJs = textInput.valueJsExpression).click { event -&gt;
    label.text(&quot;Read textInput: ${event.retrieved.jsonPrimitive.content}&quot;)
}
</code></pre>
<h2 id="preventing-the-default-event-action"><a class="header" href="#preventing-the-default-event-action">Preventing the default event action</a></h2>
<p>You can also prevent the default action of an event from occurring by setting the
<code>preventDefault</code> parameter to true - this is the equivalent of JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault">Event.preventDefault()</a>
function.</p>
<pre><code class="language-kotlin">val inputButton = button(type = ButtonType.button)
inputButton.on(preventDefault = true).click {
    logger.debug(&quot;Clicked!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-state"><a class="header" href="#rendering-state">Rendering State</a></h1>
<ul>
<li><a href="state.html#overview">Overview</a></li>
<li><a href="state.html#the-kvar-class">The KVar Class</a></li>
<li><a href="state.html#kvars-and-the-dom">KVars and the DOM</a></li>
<li><a href="state.html#binding-a-kvar-to-an-input-elements-value">Binding a KVar to an input element's value</a></li>
<li><a href="state.html#rendering-state-to-a-dom-fragment">Rendering state to a DOM fragment</a></li>
<li><a href="state.html#rendering-lists-with-rendereach">Rendering lists with renderEach</a></li>
<li><a href="state.html#extracting-data-class-properties">Extracting data class properties</a></li>
<li><a href="state.html#reversible-mapping">Reversible mapping</a></li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>A Kweb app is a function that maps state on the server to the DOM in the user's web browser. Once this 
mapping is defined, you can change the state and the browser will update automatically.</p>
<h2 id="the-kvar-class"><a class="header" href="#the-kvar-class">The KVar Class</a></h2>
<p>A <a href="https://docs.kweb.io/api/kweb-core/kweb.state/-k-var/index.html">KVar</a>
is an observable container. It contains a single typed object, which can change over time, similar to an 
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html">AtomicReference</a>. 
You can add listeners to a KVar to be notified immediately when it changes.</p>
<p>For example:</p>
<pre><code class="language-kotlin">val counter = KVar(0)
</code></pre>
<p>Here we create a counter of type <em>KVar&lt;Int&gt;</em> initialized with the
value 0.</p>
<p>We can also read and modify the value of a KVar:</p>
<pre><code class="language-kotlin">println(&quot;Counter value ${counter.value}&quot;)
counter.value = 1
println(&quot;Counter value ${counter.value}&quot;)
counter.value++
println(&quot;Counter value ${counter.value}&quot;)
</code></pre>
<p>Will print:</p>
<pre><code class="language-text">Counter value 0
Counter value 1
Counter value 2
</code></pre>
<p>KVars support powerful mapping semantics to create new KVars:</p>
<pre><code class="language-kotlin">val counterDoubled = counter.map { it * 2 }
counter.value = 5
println(&quot;counter: ${counter.value}, doubled: ${counterDoubled.value}&quot;)
counter.value = 6
println(&quot;counter: ${counter.value}, doubled: ${counterDoubled.value}&quot;)
</code></pre>
<p>Will print:</p>
<pre><code class="language-text">counter: 5, doubled: 10
counter: 6, doubled: 12
</code></pre>
<p>Note that <code>counterDoubled</code> updates automatically, because mapped KVars listen to the original for changes.</p>
<p>The <code>KVar</code> class is a subclass of <a href="https://docs.kweb.io/api/kweb-core/kweb.state/-k-val/index.html">KVal</a>, 
which is a read-only version of <code>KVar</code>.</p>
<p><strong>Note:</strong> KVars should only be used to store values that are themselves immutable, such as an Int, String, or a 
Kotlin <a href="https://kotlinlang.org/docs/reference/data-classes.html">data class</a> with immutable parameters.</p>
<h2 id="kvars-and-the-dom"><a class="header" href="#kvars-and-the-dom">KVars and the DOM</a></h2>
<p>Within the Kotlin DSL you can use the <code>kvar()</code> function to create a <code>KVar</code>. This has the advantage of calling
<code>KVar.close()</code> when this DOM fragment is cleaned up which will free up resources, and avoids having to import 
the <code>KVar</code> class.</p>
<pre><code class="language-kotlin">Kweb(port = 2135) {
    doc.body {
        val name = kvar(&quot;John&quot;)
        li().text(name)
    }
}
</code></pre>
<p>The neat part is that if the value of <em>name</em> changes, the DOM element
text will update automatically. It may help to think of this as a way of
&quot;unwrapping&quot; a KVar.</p>
<p>Numerous other functions on
<a href="https://jitpack.io/com/github/kwebio/core/0.3.15/javadoc/io.kweb.dom.element/-element/index.html">Elements</a>
support KVars in a similar manner, including
<a href="https://jitpack.io/com/github/kwebio/core/0.3.15/javadoc/io.kweb.dom.element/-element/inner-h-t-m-l.html">innerHtml()</a>
and
<a href="https://jitpack.io/com/github/kwebio/core/0.3.15/javadoc/io.kweb.dom.element/-element/set-attribute.html">setAttribute()</a>.</p>
<h2 id="binding-a-kvar-to-an-input-elements-value"><a class="header" href="#binding-a-kvar-to-an-input-elements-value">Binding a KVar to an input element's value</a></h2>
<p>For &lt;input&gt; elements you can set the value to a KVar, which will
connect them bidirectionally.</p>
<p>Any changes to the KVar will be reflected in realtime in the browser,
and similarly any changes in the browser by the user will be reflected
immediately in the KVar, for example:</p>
<pre><code class="language-kotlin">Kweb(port = 2395) {
    doc.body {
        p().text(&quot;What is your name?&quot;)
        val input = input(type = InputType.text)
        input.value = KVar(&quot;Peter Pan&quot;)
        val greeting = input.value.map { name -&gt; &quot;Hi $name!&quot; }
        p().text(greeting)
    }
}
</code></pre>
<p>This will also work for <code>&lt;option&gt;</code> and <code>&lt;textarea&gt;</code> elements which also have values.</p>
<p>See also:
<a href="https://docs.kweb.io/api/kweb-core/kweb/-value-element/index.html#-178499702%2FProperties%2F769193423">ValueElement.value</a></p>
<h2 id="rendering-state-to-a-dom-fragment"><a class="header" href="#rendering-state-to-a-dom-fragment">Rendering state to a DOM fragment</a></h2>
<p>But what if you want to do more than just modify a single element based
on a KVar, what if you want to modify a whole tree of elements?</p>
<p>This is where the <a href="https://docs.kweb.io/api/kweb-core/kweb.state/render.html">render</a></p>
<p>function comes in:</p>
<pre><code class="language-kotlin">val list = KVar(listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;))

Kweb(port = 16097) {
    doc.body {
        render(list) { rList -&gt;
            ul {
                for (item in rList) {
                    li().text(item)
                }
            }
        }
    }
}
</code></pre>
<p>Here, if we were to change the list:</p>
<pre><code class="language-kotlin">list.value = listOf(&quot;four&quot;, &quot;five&quot;, &quot;six&quot;)
</code></pre>
<p>Then the relevant part of the DOM will be redrawn instantly.</p>
<p>The simplicity of this mechanism may disguise how powerful it is, since
render {} blocks can be nested, it's possible to be very selective
about what parts of the DOM must be modified in response to changes in
state.</p>
<p><strong>Note:</strong> Kweb will only re-render a DOM fragment if the value of the KVar
actually changes so you should avoid &quot;unwrapping&quot; KVars with a
<em>render()</em> or <em>.text()</em> call before you need to.</p>
<p>The <a href="https://javadoc.jitpack.io/com/github/kwebio/core/0.3.15/javadoc/io.kweb.state/-k-val/map.html">KVal.map {}</a>
function is a powerful tool for manipulating KVals and KVars without unwrapping them.</p>
<h2 id="rendering-lists-with-rendereach"><a class="header" href="#rendering-lists-with-rendereach">Rendering lists with renderEach</a></h2>
<p>The <code>renderEach()</code> function allows you to render a list of items, while 
automatically updating the rendered DOM in response to changes in the list. </p>
<p>While a <code>KVar&lt;List&lt;FooBar&gt;&gt;</code> could be passed to <code>render()</code>, it would be
very inefficient because the entire list would be re-rendered every time.
<code>renderEach()</code> will only re-render the elements that have changed.</p>
<p>The items are provided in an <a href="https://docs.kweb.io/api/kweb-core/kweb.state/index.html#183886605%2FClasslikes%2F769193423">ObservableList</a>, which implements the 
<code>MutableList</code> interface.</p>
<pre><code class="language-kotlin">doc.body {
    data class Pet(val name : String, val age : Int)

    val obsList = ObservableList(listOf(
        Pet(&quot;Sammy&quot;, 7),
        Pet(&quot;Halley&quot;, 5),
        Pet(&quot;Buddy&quot;, 3)
    ))
    table {
        renderEach(obsList) { item -&gt;
            tr {
                td().text(item.name)
                td().text(item.age.toString())
            }
        }
    }
    obsList.add(1, Pet(&quot;Bella&quot;, 2))
    obsList.removeAt(2)
    obsList.move(0, 1)
    obsList[0] = Pet(&quot;Joe&quot;, 1)
}
</code></pre>
<h2 id="extracting-data-class-properties"><a class="header" href="#extracting-data-class-properties">Extracting data class properties</a></h2>
<p>If your KVar contains a <a href="https://kotlinlang.org/docs/reference/data-classes.html">data
class</a> then you
can use Kvar.property() to create a KVar from one of its properties
which will update the original KVar if changed:</p>
<pre><code class="language-kotlin">data class User(val name: String)

val user = KVar(User(&quot;Ian&quot;))
val name = user.property(User::name)
name.value = &quot;John&quot;
println(user) // Will print: KVar(User(name = &quot;John&quot;))
</code></pre>
<h2 id="reversible-mapping"><a class="header" href="#reversible-mapping">Reversible mapping</a></h2>
<p>If you check the type of <em>counterDoubled</em>, you'll notice that it's a
<em>KVal</em> rather than a <em>KVar</em>, meaning it cannot be modified directly, only by
changing the <em>KVar</em> it was mapped from. </p>
<p>So this will result in a compilation error:</p>
<pre><code class="language-kotlin">val counter = KVar(0)
val counterDoubled = counter.map { it * 2 }
counterDoubled.value = 20 // &lt;--- This won't compile
</code></pre>
<p>The <em>KVar</em> class has a second
<a href="https://docs.kweb.io/api/kweb-core/kweb.state/-k-var/map.html">map()</a>
function which takes a <em>ReversibleFunction</em> implementation. This version
of <em>map</em> will produce a KVar which can be modified, as follows:</p>
<pre><code class="language-kotlin">val counterDoubled = counter.map(object : ReversibleFunction&lt;Int, Int&gt;(&quot;doubledCounter&quot;) {
    override fun invoke(from: Int) = from * 2
    override fun reverse(original: Int, change: Int) = change / 2
})
counter.value = 5
println(&quot;counter: ${counter.value}, doubled: ${counterDoubled.value}&quot;)
// output: counter: 5, doubled: 10

counterDoubled.value = 12 // &lt;-- Couldn't do this with a KVal
println(&quot;counter: ${counter.value}, doubled: ${counterDoubled.value}&quot;)
// output: counter: 6, doubled: 12
</code></pre>
<p>If the mapped <em>Kvar</em> is changed the original KVar it was mapped from will also
change.</p>
<p>Reversible mappings are an advanced feature that you only need if you
want the mapped value to be a mutable KVar. Most of the time the simple
<a href="https://docs.kweb.io/api/kweb-core/kweb.state/-k-val/map.html">KVal.map {}</a>
function is what you need.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="url-routing"><a class="header" href="#url-routing">URL Routing</a></h1>
<p>In a web application, routing is the process of using URLs to drive the
user interface (UI). URLs are a prominent feature in every web browser,
and have several main functions:</p>
<ul>
<li>Bookmarking - Users can bookmark URLs in their web browser to save
content they want to come back to later.</li>
<li>Sharing - Users can share content with others by sending a link to a
certain page.</li>
<li>Navigation - URLs are used to drive the web browser's back/forward
functions.</li>
</ul>
<p>Traditionally, visiting a different URL within the same website would
cause a new page to be downloaded from the server, but current
state-of-the-art websites are able to modify the page in response to URL
changes without a full refresh.</p>
<p>With Kweb's routing mechanism you get this automatically.</p>
<h2 id="a-simple-example"><a class="header" href="#a-simple-example">A simple example</a></h2>
<pre><code class="language-kotlin">import kweb.Kweb
import kweb.dom.element.new
import kweb.dom.element.creation.tags.h1
import kweb.routing.route

fun main() {
    Kweb(port = 16097) {
        doc.body {
            route {
                path(&quot;/users/{userId}&quot;) { params -&gt;
                    val userId = params.getValue(&quot;userId&quot;)
                    h1().text(userId.map { &quot;User id: $it&quot; })
                }
                path(&quot;/lists/{listId}&quot;) { params -&gt;
                    val listId = params.getValue(&quot;listId&quot;)
                    h1().text(listId.map { &quot;List id: $it&quot; })
                }
            }
        }
    }
}
</code></pre>
<p>Now, if you visit <a href="http://localhost:16097/users/997">http://localhost:16097/users/997</a>, you will see:</p>
<kbd>
User id: 997
</kbd>
<p>The value of these parameters can then be retrieved from the <em>params</em>
map, but note that the values are wrapped in a <code>KVar&lt;String&gt;</code> object.
This means that you can use all of Kweb's <a href="https://docs.kweb.io/en/latest/state.html">state
management</a> features to
render parts of the DOM using this value.</p>
<p>The key advantage here is that if the URL changes the page can be
updated without a full page refresh, but rather only changing the parts
of the DOM that need to change - this is much faster and more efficient.</p>
<h2 id="handing-404s"><a class="header" href="#handing-404s">Handing 404s</a></h2>
<p>You can override the default 404 Page Not Found message in the event
that none of the routes match, making it easy to integrate the 404 page
with the style of your overall website:</p>
<pre><code class="language-kotlin">route {
    path(&quot;/users/{userId}&quot;) { params -&gt;
        // ...
    }
    notFound {
      h1().text(&quot;Page not found!&quot;)
    }
}
</code></pre>
<h2 id="modifying-the-url"><a class="header" href="#modifying-the-url">Modifying the URL</a></h2>
<p>You can obtain <strong>and modify</strong> the URL of the current page using
<a href="https://github.com/kwebio/kweb-core/blob/master/src/main/kotlin/kweb/WebBrowser.kt#L98">WebBrowser.url</a>.</p>
<p>This returns a <code>KVar&lt;String&gt;</code> which contains the URL relative to the
origin - so for the page <code>http://foo/bar/z</code> the <code>url</code> would be <code>/bar/z</code>.</p>
<p>Here is a more realistic example:</p>
<pre><code class="language-kotlin">import kweb.Kweb
import kweb.dom.element.creation.tags.a
import kweb.dom.element.new
import kweb.routing.route
import kweb.state.*

fun main() {
    Kweb(port = 16097) {
        doc.body {
            route {
                path(&quot;/&quot;) {
                    url.value = &quot;/number/1&quot;
                }
                path(&quot;/number/{num}&quot;) { params -&gt;
                    val num = params.getValue(&quot;num&quot;).toInt()
                    a().text(num.map {&quot;Number $it&quot;}).on.click {
                        num.value++
                    }
                }
            }
        }
    }
}
</code></pre>
<p>If you visit <code>http://localhost:16097/</code> the URL will immediately update
to <code>http://localhost:16097/number/1</code> without a page refresh, and you'll
see a hyperlink with text <code>Number 1</code>. If you click on this link you'll
see that the number increments (both in the URL and in the link text),
also without a page refresh.</p>
<p><code>num.value++</code> is worthy of additional attention. <code>num</code> is a <code>KVar&lt;Int&gt;</code>, 
and so it can be incremented via its <code>value</code> property. This will cause the 
page URL to update, which will in-turn cause the DOM to update to reflect 
the new URL. All of this is handled for you automatically by Kweb.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css--style"><a class="header" href="#css--style">CSS &amp; Style</a></h1>
<p>Kweb can integrate easily with most CSS frameworks, particularly those
that don't have a heavy reliance on JavaScript.</p>
<ul>
<li><a href="style.html#fomantic-ui">Fomantic UI</a>
<ul>
<li><a href="style.html#getting-started">Getting started</a></li>
<li><a href="style.html#example-and-demo">Example and Demo</a></li>
</ul>
</li>
<li><a href="style.html#other-ui-frameworks">Other UI Frameworks</a></li>
</ul>
<h2 id="fomantic-ui"><a class="header" href="#fomantic-ui">Fomantic UI</a></h2>
<p>Kweb has out-of-the-box support for the excellent <a href="https://fomantic-ui.com">Fomantic
UI</a> framework, which helps create beautiful,
responsive layouts using human-friendly HTML.</p>
<h3 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h3>
<p>First tell Kweb to use the Fomantic UI plugin:</p>
<pre><code class="language-kotlin">import kweb.*
import kweb.plugins.fomanticUI.*

fun main() {
    Kweb(port = 16097, plugins = listOf(fomanticUIPlugin)) {
        // ...
    }
}
</code></pre>
<p>Now the plugin will add the Fomantic CSS and JavaScript code to your
website automatically.</p>
<p>Let's look at one of the simple examples from the <a href="https://Fomantic-ui.com/elements/input.html">Fomantic
UI</a> documentation:</p>
<pre><code class="language-html">&lt;div class=&quot;ui icon input&quot;&gt;
  &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot;&gt;
  &lt;i class=&quot;search icon&quot;&gt;&lt;/i&gt;
&lt;/div&gt;
</code></pre>
<p>This translates to the Kotlin:</p>
<pre><code class="language-kotlin">Kweb(port = 16097, plugins = listOf(fomanticUIPlugin)) {
    doc.body {
        div(fomantic.ui.icon.input) {
            input(type = InputType.text, placeholder = &quot;Search...&quot;)
            i(fomantic.search.icon)
        }
    }
}
</code></pre>
<p>Take a look at the <a href="https://fomantic-ui.com">Fomantic UI documentation</a>
to see everything else it can do.</p>
<h3 id="example-and-demo"><a class="header" href="#example-and-demo">Example and Demo</a></h3>
<ul>
<li><a href="https://github.com/freenet/freenetorg-website/">freenet.org</a>
A Kweb website built on Google Cloud Platform with Fomantic styling.</li>
</ul>
<h2 id="other-ui-frameworks"><a class="header" href="#other-ui-frameworks">Other UI Frameworks</a></h2>
<p>Kweb is known to work well with a number of other CSS frameworks, including:</p>
<ul>
<li><a href="https://bulma.io/">Bulma</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<ul>
<li><a href="components.html#managing-complexity">Managing Complexity</a></li>
<li><a href="components.html#the-component-interface">The Component Interface</a></li>
<li><a href="components.html#a-simple-example">A Simple Example</a></li>
<li><a href="components.html#a-more-complex-example">A more complex example</a></li>
</ul>
<h2 id="managing-complexity"><a class="header" href="#managing-complexity">Managing Complexity</a></h2>
<p>Composable components help manage software complexity by allowing developers to break down
a complex problem into smaller, more manageable pieces. Other benefits include
reusability, testability, and the ability to reason about a system in isolation.</p>
<h2 id="the-component-interface"><a class="header" href="#the-component-interface">The Component Interface</a></h2>
<p><strong>Component</strong> (<a href="https://docs.kweb.io/api/kweb-core/kweb.state/-component/index.html?query=interface%20Component%3CR%3E">api</a>) 
is a simple but powerful abstraction to create reusable UI components in Kweb:</p>
<pre><code class="language-kotlin">/**
 * [AdvancedComponent]s can be rendered into DOM elements by calling [AdvancedComponent.render].
 *
 * Unlike [Component], [AdvancedComponent]s allows the parent element type to be configured, and a return
 * type to be specified.
 */
interface AdvancedComponent&lt;in PARENT_ELEMENT_TYPE : Element, out RETURN_TYPE&gt; {

    /**
     * Render this [Component] into DOM elements, returning an arbitrary
     * value of type [RETURN_TYPE].
     */
    fun render(elementCreator: ElementCreator&lt;PARENT_ELEMENT_TYPE&gt;) : RETURN_TYPE
}
</code></pre>
<h2 id="a-simple-example-1"><a class="header" href="#a-simple-example-1">A Simple Example</a></h2>
<pre><code class="language-kotlin">class SimpleComponent(
    val prompt: String = &quot;Enter Your Name&quot;,
    val name: KVar&lt;String&gt;
) : Component {
    override fun render(elementCreator: ElementCreator&lt;Element&gt;) {
        with(elementCreator) {
            div {
                h1().text(prompt)
                input(type = text).value = name
            }
            div {
                span().text(name.map { &quot;Hello, $it&quot; })
            }
        }
    }
}
</code></pre>
<p>This component can then be passed to <a href="https://docs.kweb.io/api/kweb-core/kweb.state/render.html">ElementCreator.render</a>:</p>
<pre><code class="language-kotlin">Kweb(port = 16097) {
    doc.body {
        render(SimpleComponent(name = kvar(&quot;World&quot;)))
    }
}
</code></pre>
<p>Components are configured through constructor parameters, typically through
a mixture of:</p>
<ul>
<li><a href="https://docs.kweb.io/api/kweb-core/kweb.state/-k-val/index.html">KVal</a>s for values that can change</li>
<li><a href="https://docs.kweb.io/api/kweb-core/kweb.state/-k-var/index.html">KVar</a>s for values that can change or be changed by the Component</li>
<li><a href="https://docs.kweb.io/api/kweb-core/kweb.state/-observable-list/index.html">ObservableList</a>s for lists of values that can change</li>
<li>Other normal classes like <strong>String</strong> for immutable values</li>
</ul>
<p>The simplest Component's may have no constructor at all, or just one or two, 
parameters, while the most complex might use a <a href="https://in-kotlin.com/design-patterns/builder-pattern/dsl/">DSL builder</a>.</p>
<p><strong>Component</strong>'s can be rendered by calling their <strong>render()</strong> method, which can return
a generically typed value (or <strong>Unit</strong> if no value is returned).</p>
<h2 id="a-more-complex-example"><a class="header" href="#a-more-complex-example">A more complex example</a></h2>
<p>In this example we create a <strong>Component</strong> that wraps an <a href="https://bulma.io/documentation/form/input/">&lt;input&gt; element</a>
styled using the <a href="https://bulma.io/">Bulma CSS framework</a>:</p>
<pre><code class="language-kotlin">class BulmaInput(
    val type : InputType,
    val color: KVal&lt;BulmaColor&gt;? = null,
    val size: KVal&lt;BulmaSize&gt;? = null,
    val style: KVal&lt;BulmaStyle&gt;? = null,
    val state: KVal&lt;BulmaState&gt;? = null,
    val disabled: KVal&lt;Boolean&gt;? = null,
    val value: KVar&lt;String&gt;
) : Component {

    override fun render(elementCreator: ElementCreator&lt;*&gt;) {
        with(elementCreator) {
            input(type = type) { inputElement -&gt;
                var inputClassList: KVal&lt;List&lt;String&gt;&gt; = kval(listOf(&quot;input&quot;))
                with(inputElement) {

                    if (color != null) {
                        inputClassList += color.map { listOf(it.cssClassName) }
                    }
                    if (size != null) {
                        inputClassList += size.map { listOf(it.cssClassName) }
                    }
                    if (this@BulmaInput.style != null) {
                        inputClassList += this@BulmaInput.style.map { listOf(it.cssClassName) }
                    }
                    if (state != null) {
                        inputClassList += state.map { listOf(it.cssClassName) }
                    }

                    if (disabled != null) {
                        this[&quot;disabled&quot;] = disabled.map { it.json }
                    }

                    classes(inputClassList.map { it.joinToString(&quot; &quot;) })

                    this.value = this@BulmaInput.value

                }
            }
        }
    }

    enum class BulmaColor(val cssClassName: String) {
        PRIMARY(&quot;is-primary&quot;),
        LINK(&quot;is-link&quot;),
        INFO(&quot;is-info&quot;),
        SUCCESS(&quot;is-success&quot;),
        WARNING(&quot;is-warning&quot;),
        DANGER(&quot;is-danger&quot;)
    }

    enum class BulmaSize(val cssClassName: String) {
        SMALL(&quot;is-small&quot;),
        NORMAL(&quot;is-normal&quot;),
        MEDIUM(&quot;is-medium&quot;),
        LARGE(&quot;is-large&quot;)
    }

    enum class BulmaStyle(val cssClassName: String) {
        ROUNDED(&quot;is-rounded&quot;),
        FOCUSED(&quot;is-focused&quot;)
    }

    enum class BulmaState(val cssClassName: String) {
        NORMAL(&quot;is-normal&quot;),
        HOVER(&quot;is-hovered&quot;),
        FOCUS(&quot;is-focused&quot;),
        LOADING(&quot;is-loading&quot;),
    }
}
</code></pre>
<p>This component can then be used like this:</p>
<pre><code class="language-kotlin">Kweb(port = 12354) {
    doc.head {
        element(&quot;link&quot;,
            attributes = mapOf(
                &quot;rel&quot; to &quot;stylesheet&quot;.json,
                &quot;href&quot; to &quot;https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css&quot;.json
            )
        )
    }

    doc.body {
        val username = kvar(&quot;&quot;)
        val color = username.map { if (it.length &lt; 5) { WARNING } else { SUCCESS }
        }
        render(BulmaInput(type = text, value = username, color = color))
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-interop"><a class="header" href="#javascript-interop">JavaScript Interop</a></h1>
<ul>
<li><a href="js.html#introduction">Introduction</a></li>
<li><a href="js.html#calling-a-javascript-function">Calling a JavaScript function</a></li>
<li><a href="js.html#calling-with-parameters">Calling with parameters</a></li>
<li><a href="js.html#function-caching-and-preloading">Function caching and preloading</a></li>
<li><a href="js.html#calling-a-javascript-function-with-a-result">Calling a JavaScript function with a result</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Kweb's DOM interaction functionality is build on top of two functions that allow you to interact
directly with the browser's JavaScript interpreter:</p>
<ul>
<li><a href="https://docs.kweb.io/api/kweb-core/kweb/-web-browser/call-js-function.html">WebBrowser.callJsFunction()</a></li>
<li><a href="https://docs.kweb.io/api/kweb-core/kweb/-web-browser/call-js-function-with-result.html">WebBrowser.callJsFunctionWithResult()</a></li>
</ul>
<p>Note that this is unrelated to Kotlin's ability to <a href="https://kotlinlang.org/docs/js-overview.html">compile to JavaScript</a>.</p>
<h2 id="calling-a-javascript-function"><a class="header" href="#calling-a-javascript-function">Calling a JavaScript function</a></h2>
<pre><code class="language-kotlin">doc.body {
    browser.callJsFunction(&quot;&quot;&quot;alert(&quot;Hello World!&quot;)&quot;&quot;&quot;)
}
</code></pre>
<h2 id="calling-with-parameters"><a class="header" href="#calling-with-parameters">Calling with parameters</a></h2>
<p>You can pass parameters to a JavaScript function by passing them as arguments to the <code>callJsFunction()</code> function,
using <code>{}</code> for substitution:</p>
<pre><code class="language-kotlin">doc.body {
    val greeting = &quot;Hello&quot;.json
    val name = &quot;World&quot;.json
    browser.callJsFunction(&quot;&quot;&quot;alert({} + &quot; &quot; + {} + &quot;!&quot;)&quot;&quot;&quot;, greeting, name)
}
</code></pre>
<p>Parameters must be converted to a <a href="https://kotlinlang.org/api/kotlinx.serialization/kotlinx-serialization-json/kotlinx.serialization.json/-json-element/">JsonElement</a>,
for example by using the <a href="https://docs.kweb.io/api/kweb-core/kweb.util/json.html">json</a> extension property. Within
the JavaScript code the <code>{}</code> should be treated like a variable, so <code>alert({})</code> is ok but <code>alert(&quot;{}&quot;)</code> will not work.</p>
<h2 id="function-caching-and-preloading"><a class="header" href="#function-caching-and-preloading">Function caching and preloading</a></h2>
<p>Kotlin automatically caches JavaScript functions in the browser for efficiency. If the function is 
first called during initial page render, it will be parsed and cached as part of the initial page load.</p>
<h2 id="calling-a-javascript-function-with-a-result"><a class="header" href="#calling-a-javascript-function-with-a-result">Calling a JavaScript function with a result</a></h2>
<p>You can also retrieve a result from a function call using <a href="https://docs.kweb.io/api/kweb-core/kweb/-web-browser/call-js-function-with-result.html">callJsFunctionWithResult()</a>.
Note that the last line of the <code>jsBody</code> parameter must be a <code>return</code> statement:</p>
<pre><code class="language-kotlin">doc.body {
    elementScope().launch {
        val result : JsonElement = browser.callJsFunctionWithResult(&quot;return Date.now()&quot;)
        println(&quot;Result: ${result.jsonPrimitive.intOrNull}&quot;)
    }
}
</code></pre>
<p><code>callJsFunctionWithResult()</code> is a suspend function so it must be called inside a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/">CoroutineScope</a>. 
You can create one within Kweb's DSL using <strong>elementScope()</strong>. This scope will be cancelled automatically
when this part of the DOM is no-longer needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="speed--efficiency"><a class="header" href="#speed--efficiency">Speed &amp; Efficiency</a></h1>
<p>Kweb is designed to be fast and efficient, both in the browser and on the server. This chapter documents some
of the techniques Kweb uses to achieve this.</p>
<ul>
<li><a href="speed.html#server-side-rendering">Server-side rendering</a></li>
<li><a href="speed.html#hydration">Hydration</a></li>
<li><a href="speed.html#websockets">WebSockets</a></li>
<li><a href="speed.html#immediate-events">Immediate events</a></li>
<li><a href="speed.html#javascript-caching">JavaScript caching</a></li>
<li><a href="speed.html#input-field-diffing">Input field diffing</a></li>
</ul>
<h2 id="server-side-rendering"><a class="header" href="#server-side-rendering">Server-side rendering</a></h2>
<p>Kweb uses the excellent <a href="https://jsoup.org/">JSoup</a> library to render the initial HTML page, which is supplied to
the browser when the page first loads. This leads to a faster initial page load, and allows search engines to index 
the page even if they aren't JavaScript aware.</p>
<h2 id="hydration"><a class="header" href="#hydration">Hydration</a></h2>
<p>Kweb uses a technique called <a href="https://en.wikipedia.org/wiki/Hydration_(web_development)">hydration</a> to add
JavaScript listeners to the DOM elements that were rendered by the server.</p>
<h2 id="websockets"><a class="header" href="#websockets">WebSockets</a></h2>
<p>After the initial page load Kweb uses WebSockets to communicate with the browser. This is more efficient than
HTTP because messages can be initiated by either the browser or the server, and the connection is kept open
between messages.</p>
<h2 id="immediate-events-1"><a class="header" href="#immediate-events-1">Immediate events</a></h2>
<p>Normal DOM events are reported to the Kweb server which then decides how to handle them. In some situations this
can cause a short but noticeable delay. <a href="events.html#immediate-events">Immediate events</a> address this by allowing
the event handler's DOM changes to be &quot;recorded&quot; by Kweb and sent to the browser in advance so it can be executed
immediately.</p>
<h2 id="javascript-caching"><a class="header" href="#javascript-caching">JavaScript caching</a></h2>
<p>After the initial page load, Kweb modifies the DOM by sending JavaScript to the browser. Much of this JavaScript
is sent as part of the initial page load, but some is sent dynamically as the user interacts with the page.
This JavaScript is parsed using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">Function</a>
(which is more efficient than <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval">eval</a>), 
and then cached in the browser for future use.</p>
<h2 id="input-field-diffing"><a class="header" href="#input-field-diffing">Input field diffing</a></h2>
<p>When an <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code> field is modified, Kweb only sends the change to the browser rather than the
entire field. This is essential for performance when the field is large, or when its being synchronised on
every keypress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<ul>
<li><a href="faq.html#wont-kweb-be-slow-relative-to-client-side-web-frameworks">Won't Kweb be slow relative to client-side web frameworks?</a></li>
<li><a href="faq.html#whats-the-difference-between-kweb-and-vaadin">What's the difference between Kweb and Vaadin?</a></li>
<li><a href="faq.html#is-there-a-larger-working-example">Is there a larger working example?</a></li>
<li><a href="faq.html#how-do-i-enable-https">How do I enable HTTPS?</a></li>
<li><a href="faq.html#can-i-embed-kweb-within-an-android-app">Can I embed Kweb within an Android app?</a></li>
<li><a href="faq.html#i-want-to-deploy-a-kweb-application-behind-a-load-balancer-what-do-i-need-to-consider">I want to deploy a Kweb Application behind a load balancer, what do i need to consider?</a></li>
<li><a href="faq.html#what-about-templates">What about templates?</a></li>
<li><a href="faq.html#why-risk-my-project-on-a-framework-i-just-heard-of">Why risk my project on a framework I just heard of?</a></li>
<li><a href="faq.html#how-is-kweb-pronounced">How is &quot;Kweb&quot; pronounced?</a></li>
<li><a href="faq.html#can-kweb-be-embedded-in-an-existing-ktor-app">Can Kweb be embedded in an existing Ktor app?</a></li>
<li><a href="faq.html#how-do-i-enable-auto-reloading">How do I enable auto-reloading?</a></li>
<li><a href="faq.html#i-have-a-question-not-answered-here">I have a question not answered here</a></li>
</ul>
<h2 id="wont-kweb-be-slow-relative-to-client-side-web-frameworks"><a class="header" href="#wont-kweb-be-slow-relative-to-client-side-web-frameworks">Won't Kweb be slow relative to client-side web frameworks?</a></h2>
<p>No, Kweb's <a href="https://docs.kweb.io/en/latest/events.html#immediate-events">immediate
events</a>
allows you to avoid any server communication delay by responding
immediately to DOM-modifying events.</p>
<p>Kweb is designed to be efficient by default, minimizing both browser and
server CPU/memory.</p>
<p>If you encounter a situation in which Kweb is slow please <a href="https://github.com/kwebio/kweb-core/issues">submit a
bug</a>.</p>
<h2 id="whats-the-difference-between-kweb-and-vaadin"><a class="header" href="#whats-the-difference-between-kweb-and-vaadin">What's the difference between Kweb and Vaadin?</a></h2>
<p>Of all web frameworks we're aware of, <a href="https://vaadin.com/">Vaadin</a> is
the closest in design and philosophy to Kweb, but there are also
important differences:</p>
<ul>
<li>Kweb is <em>far</em> more lightweight than Vaadin. At the time of writing,
<a href="https://github.com/kwebio/kweb-core">kweb-core</a> is about 4,351
lines of code, while
<a href="https://github.com/vaadin/framework">vaadin/framework</a> is currently
502,398 lines of code, almost a 100:1 ratio!</li>
<li>Vaadin doesn't have any equivalent feature to Kweb's <a href="https://docs.kweb.io/book/events.html#immediate-events">immediate
events</a>,
which has led to frequent complaints of sluggishness from Vaadin
users because a server round-trip is required to update the DOM.</li>
<li>Vaadin brought a more desktop-style of user interface to the web
browser, but since then we've realized that users generally prefer
their websites to look like websites.</li>
<li>This is why Kweb's philosophy is to be a thin interface between
server logic and the user's browser, leveraging existing tools from
the JavaScript ecosystem.</li>
<li>Kweb was built natively for Kotlin, and takes advantage of all of
its language features like
<a href="https://kotlinlang.org/docs/reference/coroutines-overview.html">coroutines</a>
and the flexible DSL-like syntax. Because of this Kweb code can be a
lot more concise, without sacrificing readability.</li>
<li>In Vaadin's favor, it has been a commercial product since 2006, it
is extremely mature and has a vast developer ecosystem, while Kweb
is still relatively new.</li>
</ul>
<h2 id="is-there-a-larger-working-example"><a class="header" href="#is-there-a-larger-working-example">Is there a larger working example?</a></h2>
<p>Yes, <a href="https://github.com/freenet/freenetorg-website/">freenet.org</a> is running on Kweb,
which is in-turn running on Google Cloud Platform with FireStore as a database.</p>
<p>You can see a number of other example Kweb projects here:
<a href="https://github.com/kwebio/kweb-demos/tree/master/">kwebio/kweb-demos</a></p>
<h2 id="how-do-i-enable-https"><a class="header" href="#how-do-i-enable-https">How do I enable HTTPS?</a></h2>
<p>Very easily, please see <a href="https://github.com/kwebio/kweb-demos/blob/master/https/src/HttpsApp.kt">this
example</a>.</p>
<h2 id="can-i-embed-kweb-within-an-android-app"><a class="header" href="#can-i-embed-kweb-within-an-android-app">Can I embed Kweb within an Android app?</a></h2>
<p>Yes! Please see
<a href="https://github.com/kwebio/kweb-demos/tree/master/android">kweb-demos/tree/master/android</a>
for an example.</p>
<h2 id="i-want-to-deploy-a-kweb-application-behind-a-load-balancer-what-do-i-need-to-consider"><a class="header" href="#i-want-to-deploy-a-kweb-application-behind-a-load-balancer-what-do-i-need-to-consider">I want to deploy a Kweb Application behind a load balancer, what do i need to consider?</a></h2>
<p>Please make sure to enable session affinity so that repeated requests
from the same client end up at the same kweb instance. Kweb does not
share its internal state between multiple instances, so it is
important to make sure that each request from a single user ends up at
always the same instance.</p>
<p>If the load balancer uses e.g. round robin strategy for load balancing,
repeated requests end up at different backend instances and kweb may not
function propery.</p>
<p>Example how to setup HAProxy can be found
<a href="https://www.haproxy.com/de/blog/load-balancing-affinity-persistence-sticky-sessions-what-you-need-to-know/">here</a>.</p>
<h2 id="what-about-templates"><a class="header" href="#what-about-templates">What about templates?</a></h2>
<p>Kweb replaces templates with something better - a typesafe HTML DSL
embedded within a powerful programming language.</p>
<p>If you like you could separate out the code that interfaces directly to
the DOM - this would be architecturally closer to a template-based
approach, but we view it as a feature that this paradigm isn't forced
on the programmer.</p>
<h2 id="why-risk-my-project-on-a-framework-i-just-heard-of"><a class="header" href="#why-risk-my-project-on-a-framework-i-just-heard-of">Why risk my project on a framework I just heard of?</a></h2>
<p>Picking a framework is stressful. Pick the wrong one and perhaps the
company behind it goes out of business, meaning your entire app is now
built on something obsolete. We've been there.</p>
<p>Kweb's development is driven by a community of volunteers. We welcome
contributions from anyone, but Kweb doesn't depend on any sponsoring
company.</p>
<p>Because of the powerful abstractions it's built on, Kweb also has the
advantage of simplicity (&lt;5k loc). This makes it easier for people to
contribute, and less code means fewer bugs.</p>
<p>That said, Kweb is still pre-1.0, one of the implications being that we
can and will make breaking API changes, and new releases are quite
frequent.</p>
<h2 id="how-is-kweb-pronounced"><a class="header" href="#how-is-kweb-pronounced">How is &quot;Kweb&quot; pronounced?</a></h2>
<p>One syllable, like <strong>qu</strong> from <strong>qu</strong>ick - <strong>qu</strong>-<strong>web</strong>.</p>
<h2 id="can-kweb-be-embedded-in-an-existing-ktor-app"><a class="header" href="#can-kweb-be-embedded-in-an-existing-ktor-app">Can Kweb be embedded in an existing Ktor app?</a></h2>
<p>Yes! Please see <a href="https://github.com/kwebio/kweb-demos/blob/master/ktorFeature/src/FeatureApp.kt">this
example</a>.</p>
<h2 id="how-do-i-enable-auto-reloading"><a class="header" href="#how-do-i-enable-auto-reloading">How do I enable auto-reloading?</a></h2>
<p>See Ktor's <a href="https://ktor.io/docs/auto-reload.html">auto-reloading</a> documentation.</p>
<h2 id="i-have-a-question-not-answered-here"><a class="header" href="#i-have-a-question-not-answered-here">I have a question not answered here</a></h2>
<p>Feel free to <a href="https://github.com/kwebio/core/issues/new">ask us a
question</a> on Github Issues,
but please search first to see whether it has already been answered. For
a more realtime experience you can also chat with us on
<a href="https://matrix.to/#/#kweb:matrix.org">Matrix</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
